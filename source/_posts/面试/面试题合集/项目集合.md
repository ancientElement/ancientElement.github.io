---
title: 项目集合
categories:
  - 面试
  - 面试题合集
date: 2023-06-07T16:14:00
tags:
  - 随手记
  - 所想
series:
  - 随手记
---
## 软光栅

读取模型数据：顶点信息，面信息，法线信息、UV信息
遍历每一个面
	遍历面中的三个顶点
		顶点阶段
			基本要求：经过MVP变换，求得屏幕坐标
			其他：获取顶点UV、法线、求光与法线的夹角
	三角形阶段：
		根据处理后的三个顶顶点的屏幕坐标，得到AABB包围盒，剔除不在三角形内的元素
			遍历三角形的每一个片元（像素）
				片元阶段
					基本要求：返回颜色值
					其他：根据重心坐标对顶点数据插值得到其他信息，例如：光与法线的夹角、纹理


## 脚本状态机

作用：**可视化**编辑状态类，添加状态、删除状态**无需编写代码**，添加过渡、删除过渡、更改过渡**无需编写代码**。加快开发速度**减少编译时间**，使得**状态脚本逻辑**清晰化。并且不仅可以用来**驱动人物**也可以用来驱动**其他逻辑**，比如**UI逻辑**。

如何运行：通过我的**RunTimeFSM配置文件**来驱动整个状态机，配置文件中有**状态列表**用来储存所有的状态，状态中有**过渡信息**，过渡中有条件信息，当状态机开始运行时，先进入初始状态。每一帧都判断当前状态的所有过渡中有没有过渡的满足过渡条件的，有则读取过渡信息过渡到下一个状态。

>List存储，因为Dictionary不可序列化，Unity没有为其编写对应的**序列化函数**，Unity自带的序列化是储存为**XML**，Unity的官方建议是自定义序列化函数，[ISerializationCallbackReceiver - Unity 脚本 API](https://docs.unity.cn/cn/2021.2/ScriptReference/ISerializationCallbackReceiver.html)

## Playable动画系统

作用：对于一些大型动作类游戏，往往会有很多的State或者Clip，并且Animator状态机是不允许**运行时添加、删除**动画的，它只能使用**OverrideController**来替换动画，这就可能导致需要一个**巨大的**Animator来满足所有可能的状态。以上原因就会导致我们的Animator密密麻麻的像**蜘蛛网**一样，非常**难以维护**，同时**Override**时也会带来非常大的性能问题。因为在动画状态机Override分成会对动画曲线进行**合并和计算**。

在Animator状态机中，是通过**定义变量**来间接控制权重的。而在Playable中，你可以**直接控制**动画的权重和时间以及其他属性，例如：我们可以让二个动画按0.2和0.8的权重混合。因此Playable相比Animator更加的灵活。

Playable还有更强大的融合特性，可以在**Clip和AnimatorController**之间混合，甚至无数个AnimatorController之间混合。在Animator系统中，二个**State machine**之间是不能过度的，但是如果使用了Playable，那就是可行的。所以我们完全可以**混用Animator状态机和Playable**。例如：一些角色的固定动画状态的转变我们可以继续用Animator状态机，而那些需要动态改变的功能我们就用Playable（这个思路很重要）。

如何运行：制作Animtor里的基本功能，单独动画节点，混合节点，Blend1D节点，Blend2D节点，在运行时加载，需要给动画时将该动画配置加载进入Playable中，并且使用Mixer过渡到加载出来的节点，过渡的方式是线性过渡，从a**lerp到**b，t就是 1/ ( lerpTime +  1e-8)。

## 基本帧同步

服务器
1. 玩家就位后发送**第0帧**的操作，第0帧都是空操作。
2. 等待**第1帧**的所有玩家操作接收到位。
	1. 接收到位后，广播所有玩家当前帧操作，当前帧加一。

客户端：
1. 等到**第0帧**的到来，**第0帧**没到不允许上传操作。
	1. 接收到第0帧后，更新逻辑帧。
2. 接收到**第0帧**后，等待66ms（FPS：15）搜集并且上传**第1帧**的操作，没有接收到不允许上传。

处理丢包：


## 物理同步

为什么使用定点数物理库?
为了消除帧同步中的**不确定性**。

帧同步中的不确定因素还有哪些？
**随机数**

随机数怎么解决？
用**随机种子**

说一下随机种子？
没有找到相关资料。

为什么使用BEPUPhysics?
BEPUPhysics是一个开源的物理引擎库，用纯C#编写，更加容易集成进入Unity。

为什么不用状态同步?
希望使用**客户端处理逻辑**。

为什么希望客户端处理逻辑？
目前没有大量的**服务器开发经验**，并且帧同步被使用在大量**单机游戏**的多人联机上，我当前开发的游戏有一定**单机性质**。
## TCP通信框架

局域网联机的实现：开启一个线程来运行服务器，内容与纯C#服务器一致。从客户端中搜索一个未被占用的端口来开启服务器。

**分包**和**粘包**：

产生的原因：

因为TCP是面向流，没有边界，而操作系统在**发送TCP数据**时，会通过**缓冲区**来进行优化，例如缓冲区为1024个字节大小。

如果**一次**请求发送的数据量**比较小**，没达到缓冲区大小，TCP则会将多个请求**合并**为同一个请求进行发送，这就形成了粘包问题。

如果一次请求发送的数据量**比较大**，超过了缓冲区大小，TCP就会将其**拆分为多次**发送，这就是拆包。

**事件监听**：

接收到消息后将消息存储在消息队列，由另外一个线程去分发。另一个线程分发事件(触发事件)，监听该事件的对象对应函数开始运行。

**心跳包机制如何实现**：

建立连接后客户端每隔一段时间向服务器发送心跳消息，服务器接收到后跟新该客户端的在线状态，如果一段时间后没有接收到，则判断玩家掉线。

什么是Protobuf？为什么使用Protobuf？

protobuf，是谷歌的开源通信协议，通过编写自定义的proto文件可以生成**多种语言**的消息代码，使用protoBuf可以支持服务端客户端**不同语言**的开发，无需自己编写序列化反序列化程序。

生成**消息类**和**消息池**的作用？

我自定义的消息类中还含有消息头，比如消息ID、消息长度。是为了区分消息，进行对应消息的分发，进行处理分包粘包。

消息池中生成了**对应的消息ID**与**消息类**的映射，**消息名称**与**消息ID**的映射，在添加**消息监听**时就可以直接用消息池中的**消息名称**，我们**反序列化**的时候就可以不需要**强转消息类型**。

```C#
AddEventListener(MessagePool.QuitMeesage_ID);

public static class MessagePool  
{  
	public static int QuitMessage_ID = 1;
}
```

## 技能编辑器

使用**UIToolKit**开发的技能编辑器，主要是UIToolKi**t可视化**开发可以加快开发进度。并且也可以同同时用传统的**IMGUI**开发。

主要是为了可视化编辑**技能配置文件**而开发的工具。

该技能配置文件可以通过编写**驱动**接入**技能驱动器**来**播放**技能配置文件中各种**轨道**上的**事件信息**。

技能驱动器每一帧会进行一次**TICK**并且调用**所有驱动**的TCIK并且传入对应的**配置文件**，和当前帧信息，比如当**前帧ID**，在驱动器中可以通过对比**当前帧ID**和配置文件中的**开始帧ID**来决定是否开始驱动。

驱动器可以编写各种逻辑信息，比如驱动**动画播放**(Simple Playable)，驱动**特效生成**(对象池)，驱动**伤害检测**(AABB，OBB，分离轴算法，Box...Overlerp)。

自动生成轨道类工具使用Unity的EditorWindow开发，输入自定义的类型信息(Type Name Color)后生成对应轨道。

Inspactor面板的可视化采用PropertyDrawer实现，如果过需要自定义可以在对应类的OnInspactor中编写。

## 游戏框架

对象池：使用Dicitonary作为容器存放需要暂存的对象，Object对象和GameObject对向有不同的容器存储。

为什么需要对象池？

GC，内存管理，标记压缩，年龄算法。。。

事件系统：

观察者模式的封装，使用Dictionary<string,Action>作为容器，可以向其中添加事件监听，通过Trigger函数找到容器中对应的string的Action触发。

委托和事件是密不可分的，委托定义这个事件的参数，返回值等等，

在声明对应的事件。

存档系统：

使用**二进制序列化**对应类存在对应的文件夹中，

实现多存档机制。

先在指定目录存放**总存档**信息，里面有**各个存档**的**ID**、**存放位置**等等。

在加载时先加载**总存档信息**，再根据ID搜索对应存档。


二进制序列化是怎么样的？

将基本数据类型转化二进制数据流，比如int类型转化为16进制。。string转化为16进制

Excel 工具：将 Excel转 ScriptableObject、Json

UI系统:使用特性类将UI资源与UI类进行绑定，对面板的生命周期进行统一管理

AB包管理器：将打包好的AB包上传至服务器，同时生成MD5对比文件方便下载时判断
哪些资源需要更新