---
title: åˆ†ç¦»è½´ç®—æ³•
categories:
  - éšæ‰‹è®°
date: 2024-02-01
tags:
  - éšæ‰‹è®°
  - ç¢°æ’æ£€æµ‹
  - æ‰€æƒ³
series:
  - éšæ‰‹è®°
---
# Reference

ç¿»è¯‘è‡ªï¼š[Separating Axis Theorem (SAT) Explanation â€“ sevenson.com.au](https://www.sevenson.com.au/programming/sat/)
# Separating Axis Theorem (SAT) Explanation  

Separating Axis Theorem (SAT) is a technique for calculating collisions between convex polygons.  
åˆ†ç¦»è½´å®šç† ï¼ˆSATï¼‰ æ˜¯ä¸€ç§è®¡ç®—å‡¸å¤šè¾¹å½¢ä¹‹é—´ç¢°æ’çš„æŠ€æœ¯ã€‚

Iâ€™m by no means an expert on it, but after the need arose for me to do some collision detection I did a pile of reading and finally got it working in ActionScript 3.  
æˆ‘ç»ä¸æ˜¯è¿™æ–¹é¢çš„ä¸“å®¶ï¼Œä½†æ˜¯åœ¨æˆ‘éœ€è¦åšä¸€äº›ç¢°æ’æ£€æµ‹ä¹‹åï¼Œæˆ‘åšäº†å¤§é‡çš„é˜…è¯»ï¼Œæœ€ç»ˆè®©å®ƒåœ¨ ActionScript 3 ä¸­å·¥ä½œã€‚

I thought I would share what I learned in the hope others wouldnâ€™t suffer so much ğŸ™‚  
æˆ‘æƒ³æˆ‘ä¼šåˆ†äº«æˆ‘æ‰€å­¦åˆ°çš„ä¸œè¥¿ï¼Œå¸Œæœ›å…¶ä»–äººä¸ä¼šé­å—é‚£ä¹ˆå¤šğŸ™‚ç—›è‹¦

When I found myself in a need to calculate collisions between polygons in flash, I came across a method known as Separating Axis Theorem (SAT). The only problem I had was that I really struggled to get a grasp on it.  
å½“æˆ‘å‘ç°è‡ªå·±éœ€è¦åœ¨ Flash ä¸­è®¡ç®—å¤šè¾¹å½¢ä¹‹é—´çš„ç¢°æ’æ—¶ï¼Œæˆ‘é‡åˆ°äº†ä¸€ç§ç§°ä¸ºåˆ†ç¦»è½´å®šç† ï¼ˆSATï¼‰ çš„æ–¹æ³•ã€‚æˆ‘å”¯ä¸€çš„é—®é¢˜æ˜¯æˆ‘çœŸçš„å¾ˆéš¾æŒæ¡å®ƒã€‚

After a lot of reading about collision detection, and looking at code samples, it all finally clicked.  
åœ¨é˜…è¯»äº†å¤§é‡æœ‰å…³ç¢°æ’æ£€æµ‹çš„å†…å®¹å¹¶æŸ¥çœ‹äº†ä»£ç ç¤ºä¾‹ä¹‹åï¼Œå®ƒç»ˆäºç‚¹å‡»äº†ã€‚

To help out the other non-maths minded people I thought I would write this quick explanation to run through the basic principles of how it works. Iâ€™ve also included a demo using SAT collision detection, as well as some ActionScript 3 classes you can download and use.  
ä¸ºäº†å¸®åŠ©å…¶ä»–ä¸æ‡‚æ•°å­¦çš„äººï¼Œæˆ‘æƒ³æˆ‘ä¼šå†™è¿™ä¸ªç®€çŸ­çš„è§£é‡Šæ¥ä»‹ç»å®ƒå¦‚ä½•å·¥ä½œçš„åŸºæœ¬åŸç†ã€‚æˆ‘è¿˜æä¾›äº†ä¸€ä¸ªä½¿ç”¨ SAT å†²çªæ£€æµ‹çš„æ¼”ç¤ºï¼Œä»¥åŠä¸€äº›æ‚¨å¯ä»¥ä¸‹è½½å’Œä½¿ç”¨çš„ ActionScript 3 ç±»ã€‚

**Note:**Â SAT does require a bit of work with vector math, so it may be a good idea to brush up on your vectors before getting too far into SAT.  
æ³¨æ„ï¼šSAT ç¡®å®éœ€è¦ä¸€äº›çŸ¢é‡æ•°å­¦æ–¹é¢çš„å·¥ä½œï¼Œå› æ­¤åœ¨æ·±å…¥ SAT ä¹‹å‰å¤ä¹ ä¸€ä¸‹çŸ¢é‡å¯èƒ½æ˜¯ä¸ªå¥½ä¸»æ„ã€‚

>è¿™é‡Œæœ‰ä¸€ä¸ªDEMOå¯ä»¥åœ¨ç½‘é¡µä¸Šé¢è¿è¡Œçš„ç¢°æ’æ£€æµ‹å®ä¾‹

![](/images/posts/Pasted%20image%2020240301134740.png)

Use your mouse to drag the shapes around. Whilst dragging, use the arrow keys to change the scale and rotation of the shapes. When the two shapes collide they will change colour (red) and show a possible reaction (grey).  
ä½¿ç”¨é¼ æ ‡æ‹–åŠ¨å½¢çŠ¶ã€‚æ‹–åŠ¨æ—¶ï¼Œä½¿ç”¨ç®­å¤´é”®æ›´æ”¹å½¢çŠ¶çš„æ¯”ä¾‹å’Œæ—‹è½¬ã€‚å½“ä¸¤ä¸ªå½¢çŠ¶ç¢°æ’æ—¶ï¼Œå®ƒä»¬ä¼šæ”¹å˜é¢œè‰²ï¼ˆçº¢è‰²ï¼‰å¹¶æ˜¾ç¤ºå¯èƒ½çš„ååº”ï¼ˆç°è‰²ï¼‰ã€‚

### The quick rundownÂ å¿«é€Ÿçº²è¦

Basically, the goal of SAT (and every other collision detection) is to test and see if is a gap between two shapes. The method that SAT uses is what makes it unique.  
åŸºæœ¬ä¸Šï¼ŒSATï¼ˆä»¥åŠæ‰€æœ‰å…¶ä»–ç¢°æ’æ£€æµ‹ï¼‰çš„ç›®æ ‡æ˜¯æµ‹è¯•å¹¶æŸ¥çœ‹ä¸¤ä¸ªå½¢çŠ¶ä¹‹é—´æ˜¯å¦å­˜åœ¨é—´éš™ã€‚SAT ä½¿ç”¨çš„æ–¹æ³•ä½¿å…¶ç‹¬ä¸€æ— äºŒã€‚

The best analogy I have heard for SAT technique is like this:  
æˆ‘å¬è¯´è¿‡çš„å…³äºSATæŠ€æœ¯çš„æœ€å¥½çš„ç±»æ¯”æ˜¯è¿™æ ·çš„ï¼š

Imagine taking a torch and shining it on the two shapes you are testing from different angles. What sort of shadows would it cast on the wall behind it?  
æƒ³è±¡ä¸€ä¸‹ï¼Œæ‹¿èµ·æ‰‹ç”µç­’ï¼Œä»ä¸åŒçš„è§’åº¦ç…§å°„ä½ æ­£åœ¨æµ‹è¯•çš„ä¸¤ä¸ªå½¢çŠ¶ã€‚å®ƒä¼šåœ¨å®ƒåé¢çš„å¢™ä¸ŠæŠ•ä¸‹ä»€ä¹ˆæ ·çš„é˜´å½±ï¼Ÿ

![](media/SAT-ShadowSide.svg)

![](media/SAT-ShadowTop.svg)

If you work your way around the shapes and never find a gap in the shadows then the objects must be touching. If you find a gap, then they are clearly not touching.  
å¦‚æœä½ åœ¨å½¢çŠ¶å‘¨å›´å·¥ä½œï¼Œå´ä»æœªåœ¨é˜´å½±ä¸­æ‰¾åˆ°é—´éš™ï¼Œé‚£ä¹ˆç‰©ä½“ä¸€å®šæ˜¯æ¥è§¦çš„ã€‚å¦‚æœä½ å‘ç°ä¸€ä¸ªç¼éš™ï¼Œé‚£ä¹ˆå®ƒä»¬æ˜¾ç„¶æ²¡æœ‰æ¥è§¦ã€‚

From a programming point of view it would be too intensive to check every possible angle. Luckily, due to the nature of the polygons, there is only a few key angles you need to check.  
ä»ç¼–ç¨‹çš„è§’åº¦æ¥çœ‹ï¼Œæ£€æŸ¥æ¯ä¸ªå¯èƒ½çš„è§’åº¦éƒ½å¤ªå¯†é›†äº†ã€‚å¹¸è¿çš„æ˜¯ï¼Œç”±äºå¤šè¾¹å½¢çš„æ€§è´¨ï¼Œæ‚¨åªéœ€è¦æ£€æŸ¥å‡ ä¸ªå…³é”®è§’åº¦ã€‚

The angles you need to check are the same as the sides of the polygons. This means that the maximum number of angles to check is the sum of the number of sides the two shapes you are testing have. Eg. Two pentagons would require ten angles to be checked.  
æ‚¨éœ€è¦æ£€æŸ¥çš„è§’åº¦ä¸å¤šè¾¹å½¢çš„è¾¹ç›¸åŒã€‚è¿™æ„å‘³ç€è¦æ£€æŸ¥çš„æœ€å¤§è§’åº¦æ•°æ˜¯è¦æµ‹è¯•çš„ä¸¤ä¸ªå½¢çŠ¶çš„è¾¹æ•°ä¹‹å’Œã€‚ä¾‹å¦‚ã€‚ä¸¤ä¸ªäº”è¾¹å½¢éœ€è¦åä¸ªè§’åº¦æ‰èƒ½æ£€æŸ¥ã€‚

![](media/WallAngle1.svg)

![](media/WallAngle2.svg)

![](media/WallAngle3.svg)

### So how do you make it work in code?  
é‚£ä¹ˆï¼Œå¦‚ä½•è®©å®ƒåœ¨ä»£ç ä¸­å·¥ä½œå‘¢ï¼Ÿ

Itâ€™s a simple but repetitive method, so here is aÂ _very basic_Â step by step.  
è¿™æ˜¯ä¸€ä¸ªç®€å•ä½†é‡å¤çš„æ–¹æ³•ï¼Œæ‰€ä»¥è¿™æ˜¯ä¸€ä¸ªéå¸¸åŸºæœ¬çš„æ­¥éª¤ã€‚

**Please Note:**Â that the code samples are just a very rough guide as to how it could be done. For a more complete working sample, check out theÂ [download](https://www.sevenson.com.au/programming/sat/#download)Â section  
è¯·æ³¨æ„ï¼šä»£ç ç¤ºä¾‹åªæ˜¯ä¸€ä¸ªéå¸¸ç²—ç•¥çš„æŒ‡å—ï¼Œè¯´æ˜å¦‚ä½•åšåˆ°è¿™ä¸€ç‚¹ã€‚æœ‰å…³æ›´å®Œæ•´çš„å·¥ä½œç¤ºä¾‹ï¼Œè¯·æŸ¥çœ‹ä¸‹è½½éƒ¨åˆ†

**Step 1.**Â Take one side from one of the polygons you are testing and find the normal (perpendicular) vector from it. This will be the â€˜axisâ€™. It needs to be a unit vector, so when you calculate it, be sure to normalize it.  
æ­¥éª¤ 1ã€‚ä»æ‚¨æ­£åœ¨æµ‹è¯•çš„å¤šè¾¹å½¢ä¹‹ä¸€ä¸­é€‰å–ä¸€æ¡è¾¹ï¼Œå¹¶ä»ä¸­æ‰¾åˆ°æ³•å‘ï¼ˆå‚ç›´ï¼‰å‘é‡ã€‚è¿™å°†æ˜¯â€œè½´â€ã€‚å®ƒå¿…é¡»æ˜¯ä¸€ä¸ªå•ä½å‘é‡ï¼Œæ‰€ä»¥å½“ä½ è®¡ç®—å®ƒæ—¶ï¼Œä¸€å®šè¦æŠŠå®ƒå½’ä¸€åŒ–ã€‚  
![](media/CodeStep1.svg)

Something a bit like:Â æœ‰ç‚¹åƒï¼š

```JavaScript
   // points / verts in the geometry.  Make sure they are in  â— ğŸ”„
   let vertices = [ {x:1, y:1}, {x:1, y:-1}, {x:-1, y:-1}, {x:-1, y:1} ];
   // get the perpendicular axis - you would need to loop over these... â— ğŸ”„
   let axis = { 
      x: -(vertices[1].y - vertices[0].y), 
      y: vertices[1].x - vertices[0].x
   }
   // be sure to normalize the axis by making it length to 1. You can do that with something like â— ğŸ”„
   let magnitude = Math.sqrt(Math.pow(axis.x,2), Math.pow(axis.y, 2));
   if (magnitude != 0)
   {
      axis.x *= 1 / magnitude;
      axis.y *= 1 / magnitude;
   }
```
**Step 2.**Â Loop through every point on the first polygon and project it onto the axis. (Keep track of the highest and lowest values found for this polygon)Â ![](media/CodeStep2.svg)  
ç¬¬2æ­¥ã€‚éå†ç¬¬ä¸€ä¸ªå¤šè¾¹å½¢ä¸Šçš„æ¯ä¸ªç‚¹ï¼Œå¹¶å°†å…¶æŠ•å½±åˆ°è½´ä¸Šã€‚ï¼ˆè·Ÿè¸ªæ‰¾åˆ°çš„æ­¤å¤šè¾¹å½¢çš„æœ€é«˜å€¼å’Œæœ€ä½å€¼ï¼‰

```JavaScript
   // helper method for calculating the dot product of a vector  
   //ç”¨äºè®¡ç®—å‘é‡çš„ç‚¹ç§¯çš„è¾…åŠ©æ–¹æ³•
   vectorDotProduct(pt1, pt2)
   {
      return (pt1.x * pt2.x) + (pt1.y * pt2.y);
   }
   // verts and axis from earlier...  
   //å‰é¢çš„é¡¶ç‚¹å’Œè½´...
   vertices = [ {x:1, y:1}, {x:1, y:-1}, {x:-1, y:-1}, {x:-1, y:1} ];    
   axis = {x:1, y: 0}  
   // get an initial min/max value.  you will need the min max for both shapes  
	//è·å–åˆå§‹æœ€å°å€¼/æœ€å¤§å€¼ã€‚ æ‚¨å°†éœ€è¦ä¸¤ç§å½¢çŠ¶çš„æœ€å°æœ€å¤§å€¼
   let p1min = vectorDotProduct(axis, vertices[0]);
   let p1max = min;
   // loop over all the other verts to complete the range  
	//åœ¨æ‰€æœ‰å…¶ä»–é¡¶ç‚¹ä¸Šå¾ªç¯ä»¥å®ŒæˆèŒƒå›´
   for (let i =1; i < verts.length; i++)
   { 
      let dot = vertices[i];
      p1min = Math.min(p1min , dot);
      p1max = Math.max(p1max , dot);
   }
```



**Step 3.**Â Do the same for the second polygon.Â ![](media/CodeStep3.svg)  
ç¬¬ 3 æ­¥ã€‚å¯¹ç¬¬äºŒä¸ªå¤šè¾¹å½¢æ‰§è¡Œç›¸åŒçš„æ“ä½œã€‚  
Now you will have both sets of vertices projected onto the axis, which is good, but they will probably be overlapping at this point because we haven't taken into consideration the distance between the two objects. (I forgot about this step until I rewrote the code, hence the picture doesn't show it...) You can correct for this spacing issue by projecting the distance between the shapes onto the same axis, then adding it to one of the shapes projection. Something kinda like this:  
ç°åœ¨ï¼Œæ‚¨å°†æŠŠä¸¤ç»„é¡¶ç‚¹æŠ•å½±åˆ°è½´ä¸Šï¼Œè¿™å¾ˆå¥½ï¼Œä½†æ˜¯å®ƒä»¬æ­¤æ—¶å¯èƒ½ä¼šé‡å ï¼Œå› ä¸ºæˆ‘ä»¬æ²¡æœ‰è€ƒè™‘ä¸¤ä¸ªå¯¹è±¡ä¹‹é—´çš„è·ç¦»ã€‚ï¼ˆåœ¨æˆ‘é‡å†™ä»£ç ä¹‹å‰ï¼Œæˆ‘å¿˜è®°äº†è¿™ä¸€æ­¥ï¼Œå› æ­¤å›¾ç‰‡æ²¡æœ‰æ˜¾ç¤ºå®ƒ......æ‚¨å¯ä»¥é€šè¿‡å°†å½¢çŠ¶ä¹‹é—´çš„è·ç¦»æŠ•å½±åˆ°åŒä¸€è½´ä¸Šï¼Œç„¶åå°†å…¶æ·»åŠ åˆ°å…¶ä¸­ä¸€ä¸ªå½¢çŠ¶æŠ•å½±æ¥çº æ­£æ­¤é—´è·é—®é¢˜ã€‚æœ‰ç‚¹åƒè¿™æ ·ï¼š

```JavaScript
   // vector offset between the two shapes  
   //ä¸¤ä¸ªå½¢çŠ¶ä¹‹é—´çš„çŸ¢é‡åç§»
   let vOffset = { polygon1.x - polygon2.x, polygon1.y - polygon2.y };
   // project that onto the same axis as just used  
	//å°†å…¶æŠ•å½±åˆ°åˆšæ‰ä½¿ç”¨çš„åŒä¸€è½´ä¸Š
   let sOffset = vectorDotProduct(axis, vOffset);
   //that will give you a scaler value that you can add to the min/max of one of the polygons from earlier  
	//è¿™å°†ä¸ºæ‚¨æä¾›ä¸€ä¸ªç¼©æ”¾å™¨å€¼ï¼Œæ‚¨å¯ä»¥å°†å…¶æ·»åŠ åˆ°å‰é¢å…¶ä¸­ä¸€ä¸ªå¤šè¾¹å½¢çš„æœ€å°å€¼/æœ€å¤§å€¼ä¸­
   p1min += sOffset;
   p1max += sOffset;

```


**Step 4.**Â Check the values you found and see if they overlap.  
ç¬¬ 4 æ­¥ã€‚æ£€æŸ¥æ‚¨æ‰¾åˆ°çš„å€¼ï¼Œçœ‹çœ‹å®ƒä»¬æ˜¯å¦é‡å ã€‚  
![](media/CodeStep4.svg)

If you find a gap between the two 'shadows' you have projected onto the axis then the shapes must not intersect. However, if there is no gap, then they might be touching and you have to keep checking until you have gone through every side of both polygons. If you get through them all without finding a gap then they collide.  
å¦‚æœå‘ç°æŠ•å½±åˆ°è½´ä¸Šçš„ä¸¤ä¸ªâ€œé˜´å½±â€ä¹‹é—´æœ‰é—´éš™ï¼Œåˆ™å½¢çŠ¶ä¸å¾—ç›¸äº¤ã€‚ä½†æ˜¯ï¼Œå¦‚æœæ²¡æœ‰é—´éš™ï¼Œé‚£ä¹ˆå®ƒä»¬å¯èƒ½ä¼šæ¥è§¦ï¼Œæ‚¨å¿…é¡»ç»§ç»­æ£€æŸ¥ï¼Œç›´åˆ°æ‚¨ç©¿è¿‡ä¸¤ä¸ªå¤šè¾¹å½¢çš„æ¯ä¸€æ¡è¾¹ã€‚å¦‚æœä½ ç©¿è¿‡å®ƒä»¬è€Œæ²¡æœ‰æ‰¾åˆ°ç¼éš™ï¼Œé‚£ä¹ˆå®ƒä»¬å°±ä¼šç¢°æ’ã€‚

```JavaScript
    //quick overlap test of the min and max from both polygons  
	//ä¸¤ä¸ªå¤šè¾¹å½¢çš„æœ€å°å€¼å’Œæœ€å¤§å€¼çš„å¿«é€Ÿé‡å æµ‹è¯•
   if ( (p1min - p2max > 0) || p2min - p1max > 0)  )
   {
      // there is a gap - bail  
	  //æœ‰ä¸€ä¸ªç¼ºå£
      return null;
   }
```


That's basically it.Â åŸºæœ¬ä¸Šå°±æ˜¯è¿™æ ·ã€‚

As an added bonus, if you keep track of which axis has the smallest shadow overlap (and how much of an overlap that was) then you can apply that value to the shapes to separate them.  
ä½œä¸ºé¢å¤–çš„å¥–åŠ±ï¼Œå¦‚æœæ‚¨è·Ÿè¸ªå“ªä¸ªè½´å…·æœ‰æœ€å°çš„é˜´å½±é‡å ï¼ˆä»¥åŠé‡å çš„ç¨‹åº¦ï¼‰ï¼Œåˆ™å¯ä»¥å°†è¯¥å€¼åº”ç”¨äºå½¢çŠ¶ä»¥åˆ†éš”å®ƒä»¬ã€‚

#### What about circles?Â åœˆå­å‘¢ï¼Ÿ

Testing a circle against a polygon in SAT is a little bit strange but it can be done.  
åœ¨ SAT ä¸­é’ˆå¯¹å¤šè¾¹å½¢æµ‹è¯•åœ†æœ‰ç‚¹å¥‡æ€ªï¼Œä½†å¯ä»¥åšåˆ°ã€‚

The main thing to note is that a circle does not have any sides so there is no obvious axis that you can test against. There is one 'not so obvious' axis you do need to test however. This is the axis that runs from the centre of the circle to the closest vertex on the polygon.  
éœ€è¦æ³¨æ„çš„ä¸»è¦äº‹æƒ…æ˜¯ï¼Œåœ†æ²¡æœ‰ä»»ä½•è¾¹ï¼Œå› æ­¤æ²¡æœ‰æ˜æ˜¾çš„è½´å¯ä»¥æµ‹è¯•ã€‚ä½†æ˜¯ï¼Œæ‚¨ç¡®å®éœ€è¦æµ‹è¯•ä¸€ä¸ªâ€œä¸å¤ªæ˜æ˜¾â€çš„è½´ã€‚è¿™æ˜¯ä»åœ†å¿ƒåˆ°å¤šè¾¹å½¢ä¸Šæœ€è¿‘é¡¶ç‚¹çš„è½´ã€‚

![](media/Circle.svg)

```JavaScript
   // presume with have some info  
	//å‡è®¾æœ‰ä¸€äº›ä¿¡æ¯
   vertices = [ {x:1, y:1}, {x:1, y:-1}, {x:-1, y:-1}, {x:-1, y:1} ];
   polygonPos = { x:0, y: 0}
   circlePos = { x: 5, y:1}
   circleRadiuis = 4;
   // find the closest by doing a distance check  
	//é€šè¿‡è¿›è¡Œè·ç¦»æ£€æŸ¥æ‰¾åˆ°æœ€è¿‘çš„
   let minDist = Number.MAX_VALUE;
   let closestDelta = null;
   let axis = null;
   for (let vert in vertices)
   {
      // make sure you are using the vert in the same space... this will depend on how you have the data set up  
	//ç¡®ä¿æ‚¨åœ¨åŒä¸€ç©ºé—´ä¸­ä½¿ç”¨ VERT...è¿™å–å†³äºæ‚¨å¦‚ä½•è®¾ç½®æ•°æ®
      let worldVert = { x: polygonPos.x + vert.x, y: polygonPos.y + vert.y }
      // delta between the circle and this vert in world space.  
	//ä¸–ç•Œç©ºé—´ä¸­åœ†åœˆå’Œè¿™ä¸ªé¡¶ç‚¹ä¹‹é—´çš„ä¸‰è§’æ´²ã€‚
      let delta= { x: worldVert.x - circlePos.x, y: worldVert.y - circlePos.y }
      // use pythagoras theorem to get the distance - you can skip the sqrt because we don't need the true distance in this check  
	//ä½¿ç”¨æ¯•è¾¾å“¥æ‹‰æ–¯å®šç†æ¥è®¡ç®—è·ç¦» - æ‚¨å¯ä»¥è·³è¿‡ sqrtï¼Œå› ä¸ºåœ¨æ­¤æ£€æŸ¥ä¸­æˆ‘ä»¬ä¸éœ€è¦çœŸå®è·ç¦»
      let dist = Math.pow(delta.x, 2) +  Math.pow(delta.y, 2));
      if (dist < minDist)
      {
	     minDist = dist;
	     closestDelta = delta;
      }
   }
   // you can now convert the closest delta into a unit vector axis  
	//æ‚¨ç°åœ¨å¯ä»¥å°†æœ€è¿‘çš„å¢é‡è½¬æ¢ä¸ºå•ä½çŸ¢é‡è½´
   let magnitude = Math.sqrt(Math.pow(closestDelta.x,2), Math.pow(closestDelta.y, 2));
   if (magnitude != 0)
   {
      axis.x = closestDelta.x * (1 / magnitude);
      axis.y = closestDelta.x * (1 / magnitude);
   }
```


After that it is just a matter of going through the usual routine of looping through every axis on the other polygon and checking for overlaps.  
ä¹‹åï¼Œåªéœ€å®Œæˆå¸¸è§„ä¾‹ç¨‹ï¼Œå³å¯éå†å¦ä¸€ä¸ªå¤šè¾¹å½¢ä¸Šçš„æ¯ä¸ªè½´å¹¶æ£€æŸ¥é‡å ã€‚

Oh, and in case you are wondering how to project a circle onto the axis, you simply project the centre point of the circle and then add and subtract the radius.  
å“¦ï¼Œå¦‚æœä½ æƒ³çŸ¥é“å¦‚ä½•å°†åœ†æŠ•å½±åˆ°è½´ä¸Šï¼Œä½ åªéœ€æŠ•å½±åœ†çš„ä¸­å¿ƒç‚¹ï¼Œç„¶ååŠ å‡åŠå¾„ã€‚

```JavaScript
   // props from earlierÂ æ—©æœŸçš„é“å…·
   // axis = {x:1, y: 0}  
   // circleCenter = {x:5, y:1 }  
   // project the centerÂ é¡¹ç›®ä¸­å¿ƒ
   let temp = vectorDotProduct(axis, circleCenter );
   // calc the range using the radius  
	//ä½¿ç”¨åŠå¾„è®¡ç®—èŒƒå›´
   let circleMin = temp - circleRadius;
   let circleMax = temp + circleRadius;
   // Now use this range to do the overlap test described earlier...  
   //ç°åœ¨ä½¿ç”¨æ­¤èŒƒå›´è¿›è¡Œå‰é¢æè¿°çš„é‡å æµ‹è¯•...
```
### Pros and ConsÂ ä¼˜ç‚¹å’Œç¼ºç‚¹

Like all collision detection techniques, SAT has it's pro's and cons. Here is a quick rundown of some of them:  
åƒæ‰€æœ‰ç¢°æ’æ£€æµ‹æŠ€æœ¯ä¸€æ ·ï¼ŒSATä¹Ÿæœ‰å…¶ä¼˜ç‚¹å’Œç¼ºç‚¹ã€‚ä»¥ä¸‹æ˜¯å…¶ä¸­ä¸€äº›çš„ç®€è¦ä»‹ç»ï¼š

Pros

- It is fast - It uses pretty basic vector math and you can bail out of a test as soon as a gap is detected, eliminating unnecessary calculations.  
    å®ƒé€Ÿåº¦å¾ˆå¿« - å®ƒä½¿ç”¨éå¸¸åŸºæœ¬çš„å‘é‡æ•°å­¦ï¼Œä¸€æ—¦æ£€æµ‹åˆ°å·®è·ï¼Œæ‚¨å°±å¯ä»¥é€€å‡ºæµ‹è¯•ï¼Œä»è€Œæ¶ˆé™¤ä¸å¿…è¦çš„è®¡ç®—ã€‚
- It is accurate - at least as far as I can tell.  
    è¿™æ˜¯å‡†ç¡®çš„â€”â€”è‡³å°‘æ®æˆ‘æ‰€çŸ¥ã€‚

Cons

- It only works with Convex polygons - complex shapes are out unless you build them out of smaller convex shapes, and then test each individual shape.  
    å®ƒä»…é€‚ç”¨äºå‡¸å¤šè¾¹å½¢ - é™¤éæ‚¨ä»è¾ƒå°çš„å‡¸å½¢ä¸­æ„å»ºå®ƒä»¬ï¼Œç„¶åæµ‹è¯•æ¯ä¸ªå•ç‹¬çš„å½¢çŠ¶ï¼Œå¦åˆ™å¤æ‚å½¢çŠ¶å°†è¢«æ’é™¤åœ¨å¤–ã€‚
- It doesn't tell you which sides are touching - only how far they are overlapping and the shortest distance to separate them.  
    å®ƒä¸ä¼šå‘Šè¯‰ä½ å“ªäº›æ–¹é¢æ˜¯æ¥è§¦çš„ï¼Œåªæ˜¯å‘Šè¯‰ä½ å®ƒä»¬é‡å çš„è·ç¦»å’Œåˆ†å¼€å®ƒä»¬çš„æœ€çŸ­è·ç¦»ã€‚

There is probably a bunch more but these were the main ones I could think of.  
å¯èƒ½è¿˜æœ‰å¾ˆå¤šï¼Œä½†è¿™äº›æ˜¯æˆ‘èƒ½æƒ³åˆ°çš„ä¸»è¦çš„ã€‚

### Conclusion

I hope that this has helped to shed some light on the separating axis theorem. I've tried to keep it as simple as possible without shedding too much information. (I'm by no means an expert in maths so I apologise if I left anything out)  
æˆ‘å¸Œæœ›è¿™æœ‰åŠ©äºé˜æ˜åˆ†ç¦»è½´å®šç†ã€‚æˆ‘è¯•å›¾è®©å®ƒå°½å¯èƒ½ç®€å•ï¼Œè€Œä¸ä¼šæ³„éœ²å¤ªå¤šä¿¡æ¯ã€‚ï¼ˆæˆ‘ç»ä¸æ˜¯æ•°å­¦ä¸“å®¶ï¼Œæ‰€ä»¥å¦‚æœæˆ‘é—æ¼äº†ä»€ä¹ˆï¼Œæˆ‘æ·±è¡¨æ­‰æ„ï¼‰

Here are a few links to other pages that helped me understand SAT collision detection.  
ä»¥ä¸‹æ˜¯ä¸€äº›æŒ‡å‘å…¶ä»–é¡µé¢çš„é“¾æ¥ï¼Œè¿™äº›é¡µé¢å¸®åŠ©æˆ‘äº†è§£äº† SAT ç¢°æ’æ£€æµ‹ã€‚

- [harverycartel.org](http://www.harveycartel.org/metanet/tutorials/tutorialA.html)Â - more detailed descriptions and some cool interactive examples. I learnt a lot from this page.  
    harverycartel.org - æ›´è¯¦ç»†çš„æè¿°å’Œä¸€äº›å¾ˆé…·çš„äº¤äº’å¼ç¤ºä¾‹ã€‚æˆ‘ä»è¿™ä¸ªé¡µé¢å­¦åˆ°äº†å¾ˆå¤šä¸œè¥¿ã€‚
- [GPWiki.org](http://gpwiki.org/index.php/VB:Tutorials:Building_A_Physics_Engine:Basic_Intersection_Detection)- good SAT explanation and sample code - I used this as a basis for creating my own code.  
    GPWiki.org - è‰¯å¥½çš„ SAT è§£é‡Šå’Œç¤ºä¾‹ä»£ç  - æˆ‘ä»¥æ­¤ä¸ºåŸºç¡€åˆ›å»ºè‡ªå·±çš„ä»£ç ã€‚
- [Tony Pa](http://www.tonypa.pri.ee/vectors/index.html)Â - Vector tutorials - Good resource for learning about Vectors  
    Tony Pa - Vector æ•™ç¨‹ - å­¦ä¹  Vectors çš„å¥½èµ„æº
- [GameDev.net forum](http://www.gamedev.net/community/forums/topic.asp?topic_id=251638)Â - a SAT collision system a member created - gave me some ideas on how to calculate reactions, etc.  
    GameDev.net è®ºå› - ä¸€ä¸ªæˆå‘˜åˆ›å»ºçš„SATç¢°æ’ç³»ç»Ÿ - ç»™äº†æˆ‘ä¸€äº›å…³äºå¦‚ä½•è®¡ç®—ååº”ç­‰çš„æƒ³æ³•ã€‚

### Download:

If you want to see the code for my interactive demo, you can grab them from myÂ [SAT_JS GitHub Repo](https://github.com/sevdanski/SAT_JS). It is in no way optimised but should serve as a good example of the above explanation.  
å¦‚æœä½ æƒ³æŸ¥çœ‹æˆ‘çš„äº¤äº’å¼æ¼”ç¤ºçš„ä»£ç ï¼Œä½ å¯ä»¥ä»æˆ‘çš„ SAT_JS GitHub Repo ä¸­è·å–å®ƒä»¬ã€‚å®ƒç»ä¸æ˜¯ä¼˜åŒ–çš„ï¼Œä½†åº”è¯¥ä½œä¸ºä¸Šè¿°è§£é‡Šçš„ä¸€ä¸ªå¾ˆå¥½çš„ä¾‹å­ã€‚  
(The originalÂ [AS3 version](https://github.com/sevdanski/SAT_AS3)Â is also available is you are so inclined)  
ï¼ˆåŸå§‹çš„ AS3 ç‰ˆæœ¬ä¹Ÿå¯ç”¨ï¼Œæ‚¨æ„¿æ„ï¼‰

Basically, you create two shapes from the (SATPolygon or SATCircle classes) and then test them with the static 'SAT.test()' method. If they touch then a 'CollisionInfo' object will be returned. If they don't touch then it will return 'null'. The CollisionInfo object has a bunch of information about the collision that can be used to separate the two objects, etc.  
åŸºæœ¬ä¸Šï¼Œæ‚¨ä»ï¼ˆSATPolygon æˆ– SATCircle ç±»ï¼‰åˆ›å»ºä¸¤ä¸ªå½¢çŠ¶ï¼Œç„¶åä½¿ç”¨é™æ€çš„â€œSAT.testï¼ˆï¼‰â€æ–¹æ³•æµ‹è¯•å®ƒä»¬ã€‚å¦‚æœå®ƒä»¬æ¥è§¦ï¼Œåˆ™å°†è¿”å›â€œCollisionInfoâ€å¯¹è±¡ã€‚å¦‚æœä»–ä»¬ä¸æ¥è§¦ï¼Œé‚£ä¹ˆå®ƒå°†è¿”å›â€œnullâ€ã€‚CollisionInfo å¯¹è±¡æœ‰ä¸€å †å…³äºç¢°æ’çš„ä¿¡æ¯ï¼Œå¯ç”¨äºåˆ†éš”ä¸¤ä¸ªå¯¹è±¡ç­‰ã€‚

The SATDemo class contains all the logic for creating the demo shown earlier in this post.  
SATDemo ç±»åŒ…å«ç”¨äºåˆ›å»ºæœ¬æ–‡å‰é¢æ‰€ç¤ºçš„æ¼”ç¤ºçš„æ‰€æœ‰é€»è¾‘ã€‚