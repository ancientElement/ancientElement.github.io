---
title: 面经千千问
date: 2024-03-15 20:23
tags:
  #### 随手记
  #### 所想
---
## 准备完成的

c++:
#### 内存碎片如何解决(也只有C++问这个问题了)
#### 如何实现C++多态、C++多态，虚函数，虚函数表(提到两次了)
#### STL中的多继承 菱形继承
#### 虚继承原理
#### 右值引用和移动语义
#### C++内存管理方式智能指针
#### shared ptr的具体实现（问的很细
#### 静态联编和动态联编
#### map和unordermap底层，区别，时间复杂度
#### 各种STL容器底层实现
#### vector和list的使用场景
#### stack适配器的底层容器是什么，能不能用vector，为什么
#### 多态原理

unity C\#:

#### 讲一下RTTI
#### 讲一下RTTI（没听说过，面试官提示我四种类型转换），讲一下dynamic_cast原理（不会，瞎猜了一个跟虚函数表有关）。
#### 裁剪发生在具体哪个阶段

#### 有GC还会产生内存泄漏吗
#### collider trigger区别

#### 多态原理
#### 描边 第二个实现手段
#### UI的边不清晰模糊有锯齿是什么原因造成的(是指纹理采样吗？抗锯齿？图片压缩格式)

#### 安卓IOS混合开发**√HALF**
#### 性能优化**√LEARNING**
#### 我的这个帧同步怎么减小网络延迟(更换为TCP？)

## 完成的
#### 背景循环是怎么做的？ (这是他的项目,应该关系不大)
####  镜头跟随是怎么做的？(这个也是他的项目,但是我因该去看看CatMovement的相机)

#### Lua和C#的核心的交互原理

#### Unity的网络同步了解多少？


#### 帧同步的注意点 **灵**
[帧同步优化难点及解决方案 - UWA问答 | 博客 | 游戏及VR应用性能优化记录分享 | 侑虎科技 (uwa4d.com)](https://blog.uwa4d.com/archives/USparkle_frame-alignment.html)
定点数
确定性物理引擎
随机数 
不确定排序容器 
多线程 
不使用Coroutine 
必须要有统一的逻辑帧Tick,来更新整个战斗逻辑，而不是每个逻辑自己去Update,因为需要保证每次执行的顺序一致
显示和逻辑相分离 比如事件触发不能依赖于动画

#### 为什么使用帧同步 **灵**
为了在客户端开发逻辑 只是使用服务器进行转发 加快开发效率
流量稳定 消耗低 1个字节 varints编码 状态同步流量消耗是不稳定的
我这边计划的战斗人数是较少的一般一个房间是10人之内不会对客户端造成太大的性能压力

缺点的话主要是:
不能太多人一起在一个房间,因为帧同步客户端要跑所有玩家的逻辑

#### 怎么减少延迟
**基于可靠传输的UDP**，是指在UDP上加一层封装，自己去实现丢包处理，消息序列，重传等类似TCP的消息处理方式，保证上层逻辑在处理数据包的时候，不需要考虑包的顺序，丢包等。类似的实现有Enet，KCP等。

**冗余信息的UDP**，是指需要上层逻辑自己处理丢包，乱序，重传等问题，底层直接用原始的UDP，或者用类似Enet的Unsequenced模式。常见的处理方式，就是两端的消息里面，带有确认帧信息，比如客户端(C)通知服务器(S)第100帧的数据，S收到后通知C，已收到C的第100帧，如果C一直没收到S的通知（丢包，乱序等原因），就会继续发送第100帧的数据给S，直到收到S的确认信息。
#### 讲一下KCP **记得补充**


#### 除了重传，还有什么办法减少udp丢包？（没答出来）
是指在UDP上加一层封装，自己去实现丢包处理，消息序列，重传等类似TCP的消息处理方式，保证上层逻辑在处理数据包的时候，不需要考虑包的顺序，丢包等。类似的实现有Enet，KCP等。
#### 让你自己写可靠UDP怎么做好一点？（答得很平常，面试官没反应）
1.解决方法:发送时使用usleep(1)**延迟1微秒**发送,即发送频率不要过快,延迟1微妙发送,可以很好的解决这个问题.
2.使用前向纠错（Forward Error Correction, FEC）：前向纠错技术可以在发送方添加一些**冗余数据**，使接收方能够在接收到部分数据包时也能恢复丢失的数据。你可以在应用层实现前向纠错机制，以提高数据的可靠性。
3.**增加接收缓冲区大小**：通过增加接收缓冲区的大小，可以减少[丢包](https://so.csdn.net/so/search?q=%E4%B8%A2%E5%8C%85&spm=1001.2101.3001.7020)的可能性。你可以使用`setsockopt`函数设置套接字的接收缓冲区大小，例如： int bufferSize = 1024 * 1024; // 设置为1MB
4.使用确认机制：尽管UDP本身没有确认机制，但你可以在应用层添加确认机制。例如，在发送数据时，要求接收方发送确认消息，以确保数据的完整性和正确性。

即使有一个包丢包了也可以从其他两个之间包求解

#### 对一个对象的生命周期是怎么理解的？
创建 存在 销毁

#### 几何着色器?(什么是几何着色器,难道是片元着色器吗?)
然而，几何着色器最有趣的地方在于，它能够将（这一组）顶点**变换为完全不同的图元**，并且还能**生成比原来更多的顶点**。
法线可视化 LOD

####  屏幕内有大量的圆形在实时移动，我要实时输出它们的碰撞关系，我该如何实现？如果有1w个你还要暴力吗？ **灵**
1.使用四叉树或者网格划分做场景管理,如果一个场景中的圆形动了,我们计算这个格子内的碰撞关系,和他附近的格子的碰撞关系,
2.SAP算法全称**Sweep And Prune** ，又称扫掠算法。
3.MBP算法全称**Multi Box Pruning**，本质上就是SAP + 网格。如何做，看图一眼便知

#### 射线与三角片相交检测
1.MT算法
[射线和三角形的相交检测（ray triangle intersection test） #### 翰墨小生 #### 博客园 (cnblogs.com)](https://www.cnblogs.com/graphics/archive/2010/08/09/1795348.html)

[一文读懂射线与三角形相交算法Moller-Trumbore算法 #### (oakchina.cn)](https://www.oakchina.cn/2022/02/16/moller-trumbore/)

2.(可能行不通)可以用轴对称OBB检测类似的算法,将三角形投影到与射线垂直的方向上,再判断是否有间隙

#### 了解过NavMesh训路吗？**灵**
https://zhuanlan.zhihu.com/p/454839684
体素化 A* 三角形剖分 漏斗算法 

#### 稳定的排序有哪些？
冒泡  插入 归并 桶排序

冒泡: 遍历数组每次将大的放在后面

```cpp
void sort(vector<int>& arr) {
	for(int i=0;i<arr.size();i++) {
		for(int j=i+1;j<arr.size();j++) {
			if(arr[j]<arr[j-1]) swap(arr[j],arr[j-1]);
		}
	}
}
```

归并: 划分数组为两个部分,再对划分的部分排序,排序之后合拼成有序数组 需要辅助空间

```cpp
void sort(vector<int> nums,vector<int> help,int start,int end) {
	if(end>=start) return;
	int mid=(end-start)/2;
	//递归划分 
	//递归划分到最小
	sort(nums,help,start,mid);
	sort(nums,help,mid+1,end);
	//出来之后合并  小的放到help的前面
	//在help中排序
	int k=start,p1=start,p2=mid+1;
	while(p1<=mid&&p2<=end) help[k++]=nums[p1]<nums[p2]?nums[p1++]:nums[p1++];
	//如果有一个遍历完了
	while(p1<=mid) help[k++]=nums[p1++];
	while(p2<=end) help[k++]=nums[p2++];
	//将help的结果给nums
	for(int i=start;i<=end;i++) nums[i]=help[i];
}
void sort(vector<int> nums) {
	vector<int> help;
	sort(nums,help,0,nums.size());
}
```

快排: 
快速排序:

```cpp
void sort(vector<int> nums,int start,int end) {
	//得到基准值
	int p=nums[start],left=start,right=end;
	//将大于p放到左边小于p放到右边
	while(left<right) {
		//从右边到左边 当右边大于p
		while(left<right&&nums[right]>p) right--;
		//找到小于p的数
		if(left<right) nums[left++]=nums[right];
		while(left<right&&nums[left]<p) left++;
		if(left<right) nums[right--]=nums[left];
	}
	nums[left]=p;
	//递归左右区间
	sort(nums,start,left-1);
	sort(nums,left+1,end);
}
void sort(vector<int> nums) {
	sort(nums,0,nums.size()-1);
]
```

#### 平时开发过程中用到哪些框架了吗？
使用的游戏框架是我自己写的

#### 都用过哪些设计模式？
MVC,观察者,命令模式,工厂模式

#### 对网络了解的多吗？通信协议之类的？
TCP协议比较了解

####  客户端到服务端发送数据用什么协议这个有了解吗？
我现在使用的TCP协议,打算在上线之后更换UDP

#### 网络协议有几层有了解吗？
物理层,    数据链路层, 网络层,      传输层,         应用层
(传输媒介)(封装成帧)  (IP数据报)  (TCP/UDP)    (HTTP/DNS)
#### 对链表熟悉吗？链表反转、合并、删除什么的都怎么操作？
对链表进行这些操作时我们常用一个虚拟头节点作为链表的头节点,因为可能会使得链表的头部变化

#### 对图形学了解多少？这方面熟悉吗？比如说点乘和叉乘代表什么几何意义？或者矩阵运算这种？
这种还是比较了解的,点乘代表内积几何意义是一个向量在另外一个向量上的投影,或者说可以得到角度($cos(\theta)$),叉乘代表外积,几何意义是得到同时垂直于两个向量的向量,可以用来判断两个向量的相对关系。在图形学中常用矩阵做仿射变换，比如平移、缩放、旋转、剪裁矩阵等等。

#### 平时开发过程中有用过行为树和状态机吗？能说一下它们吗？
使用状态机比较多，状态机主要由状态、过渡、条件组成，由状态机控制器同一管理所有状态的运行。

行为树由节点构成,有控制节点: 序列节点(Sequence) 备选节点(Fallback) 并行节点(Parraller) 修饰节点(定义孩子节点放回的状态信息),执行节点: 动作节点 条件节点。

#### 动画系统了解有多少？
#### Animator骨骼动画。Animator骨骼动画   **灵**
#### 角色动画有了解吗？播动画用什么接口？追问：做过两个动作过渡的效果吗？
#### 你这个切换Animator的时候会不会有跳帧的感觉？如何处理的？

[浅谈骨骼动画技术原理（一）：基本介绍 #### 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/431446337)
[【Unity动画系统】汇总篇 #### 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/492136094)
动画系统：
Unity中现有的动画系统是Mecanim动画系统，主要用于人形动画集成了人形动画重定向，肌肉控制和状态机。动画状态机Override(性能消耗主要点)  动画分层(对人形的每一个部分进行动画控制) 

骨骼定义了人的关节，每一个关节运动都会带动其子节点运动，蒙皮是将模型的皮肤绑定在骨骼上，定义了模型相对于骨骼的位置

还有Legacy动画系统主要用于非人形动画。

Unity 2D Freeform Cartesian 笛卡尔坐标下下的权重分配

Unity 2D Freeform Directional 极坐标系下的权重分配

关于骨骼动画：
通过将顶点绑定到骨骼上达到模型移动的效果
骨骼 关节 蒙皮（顶点）
关节记录的是相对于父节点的坐标
正向动力学解决从骨骼坐标下 转换到世界坐标 （通过TR矩阵 相对于父节点的位移和旋转）
反向向动力学解决了，动画移动需要记录大量关节的旋转与位移，只要移动一个骨骼就可以得到其他骨骼的运动，使用循环坐标下降法

关于跳帧：
制作动作的过渡可以使用1DblendTree进行插值，由我们自己控制混合
用1DblendTree做插值 $f(t)=tp_0+(1-t)p_1$

#### 做项目的时候有考虑内存吗？
对资源的导入设置方面有关注过,比如音频、纹理、动画的大小等等,我们可以根据不同资源的特性与平台不同对资源进行压缩，频繁生销毁的对象可以用对象池。

#### 如果一个大型游戏的话，你该如何管理内存呢？
#### 加载资源用的是什么接口？为什么不用AB包或者AssetDatabase？
[Unity Addressables Tutorial: Learn the Basics | TheGamedev.Guru --#### Unity 可寻址教程：学习基础知识 |游戏开发大师](https://thegamedev.guru/unity-addressables/tutorial-learn-the-basics/)
1.我使用**Addressable**来加载资源，使用Addressable加载资源可以**减少对内存**的使用大小，例如我们在脚本中正常持5个对象，并且在Inspector面板中为他赋值了，那么运行时将会将这5个对象全部加载进入内存。
但是用AddressableRerference，资源会在AB包中，我们面板里只是持有了可寻址对象的引用，占用内存非常少。

另外就是Addressable的资源管理，他通过计数的方式，加载对象引用数量就加1，释放对象引用数量减一，引用数量为零就将该**资源卸载**。

2.可以使用Unity官方的UPRAssetsChecker工具进行分析，对相应的内存进行管理

#### Animator Controller 分层有了解吗？
Animator的分层可以提供不同的遮罩，让人形的部分运动，也可以设置权重，使得多个State同时作用。可以是两个动画叠加也可以不同部分有不同的动画。比如下半身奔跑、上半身持枪之类的。

#### 静态合批和动态合批优缺点**√**
静态合批将多个Mesh合并成为一个，减少了DrawCall的次数，降低CPU开销提高了渲染效率，
并且合并之后减少了顶点缓冲区的内存，
但是静态合批不灵活，只能使用在静态网格上，
而且如果是大量物体的静态合批可能会**占用较多的内存** 
静态批处理的主要**限制**是每批可以具有**的顶点和索引的数量**，通常为每个64k，

动态合批适用于Mesh会改变的对象，
能够实时生成顶点数据，无需在内存中保存顶点数据，节约了内存空间，
但是动态合批会在每一帧重新计算顶点数据，
每一次更新渲染数据都会调用一次DrawCallCPU开销大。

使用合批的前提是游戏对象使用相同的材质，我们可以使用工具来合并不同的Mesh，比如下面插件
-Mesh Baker：[高级](https://link.zhihu.com/?target=https%3A//assetstore.unity.com/packages/tools/modeling/mesh-baker-5017)或[免费](https://link.zhihu.com/?target=https%3A//assetstore.unity.com/packages/tools/modeling/mesh-baker-free-31895)
-[Super Combiner](https://link.zhihu.com/?target=https%3A//assetstore.unity.com/packages/tools/modeling/super-combiner-92129)
-[Advanced Batcher](https://link.zhihu.com/?target=https%3A//assetstore.unity.com/packages/tools/utilities/advanced-batcher-19877)
-[One Batch](https://link.zhihu.com/?target=https%3A//assetstore.unity.com/packages/tools/utilities/one-batch-128259)
-[Mesh Combine Studio 2](https://link.zhihu.com/?target=https%3A//assetstore.unity.com/packages/tools/modeling/mesh-combine-studio-2-101956)（个人推荐）

#### 对Unity的DrawCall了解多少？
DrawCall就是CPU想GPU发送命令进行一次渲染，CPU需要准备Mesh信息、材质信息给GPU
我们可以通过合批来减少DrawCall次数

#### 我看你本地数据持久化使用的Json，用的是自带的JsonUtility吗？用这个原生的包有没有什么比较烦的地方？
对于自定义类需要加可序列化特性、不支持私有对象、不支持直接解析`[]`中的数据集合，不支持字典

#### $A^*$寻路？你用的Unity自带的NavMesh实现自动寻路，有没有考虑自己写一个寻路算法？大量小兵一起怎么寻路  ？   **灵4**
我目前接触所有的寻路算法都是： 找到**相邻节点**去往终点**代价最小**的节点，而$A^*$寻路在**计算代价上**同时使用了**已经走过的消耗**和**未来到达终点的消耗**，我们称之为启发函数。
不同的启发函数会带来不同的结果。例如 欧几里得启发函数(适合3D寻路 任意方向) 和 曼哈顿启发函数(适合格子寻路 只能上下左右)

$A^*$寻路的基本原理：
$A^*$寻路的过程很像BFS，维护两个列表我们在$A^*$中通常叫他们开启列表和关闭列表（其实在BFS中一个是Queue 和 Visted数组）
一开始把起点加入到开启列表，
然后当开启列表不为空时 循环
	从开启列表中得到一个由启发函数计算出来的优先级最高的节点 cur
		判断是否是终点
			是终点，从终点开始往上寻找父节点，返回路径
		否则
			遍历其相邻节点
				跳过Close中的节点
				跳过无法行走的节点
				设置父节点为cur
				使用启发函数计算优先级保存
				将其加入Open列表中

大量角色的寻路的话，可以分为大寻路和小寻路，整体朝一个方向寻路而每个个体又相对于自己在阵列中的对应位置寻路

#### 取一个结构体的大小往往不等于内部所有元素的大小，为什么？(内存对齐)。追问：那举个例子：结构体有三个元素，第一个是double，第二个是int，第三个是char那这个结构体的大小是多少？**灵2**
因为要内存对齐，内存对齐能够提高CPU在内存中读取数据的效率。数据结构(尤其是栈)应该尽可能地在**自然边界上对齐**。原因在于，为了访问未对齐的内存，处理器需要作两次内存访问；而对齐的内存访问仅需要一次访问

对齐规则
1.**数据成员对齐规则**：结构(struct)(或联合(union))的数据成员，第一个数据成员放在offset为0的地方，以后每个数据成员的对齐按照#pragma pack指定的数值和这个数据成员自身长度中，比较小的那个进行;  
2.**结构(或联合)的整体对齐规则**：在数据成员完成各自对齐之后，结构(或联合)本身也要进行对齐，对齐将按照#pragma pack指定的数值和结构(或联合)最大数据成员长度中，比较小的那个进行;

结构体有三个元素，第一个是double，第二个是int，第三个是char那这个结构体的大小是多少？
double 8字节
int 4字节 
char 1字节 (补齐3)
根据C++的内存对齐规则这个结构体大小是16字节

#### 你能介绍一些常见STL的容器和它的原理吗 **灵4**  
*追问：vector的底层实现原理是什么？*
 
常见STL容器vector、unordered_set、unordered_map、queue、stack、

>[C++中push_back和emplace_back的区别 #### 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/213853588)总结就是：emplace_back(构造参数列表)只调用一次构造函数，而push_back(构造参数列表)会调用一次构造函数+一次移动构造函数。其余情况下，二者相同。

vector的实现是动态数组，根据容器中的元素数量进行扩容，超出空间时会分配一块，大小为现在的大小的1.5倍的空间，并且将现在的元素拷贝到新的空间中，然后将之前的内存释放。源码如下

```cpp
size_type _Calculate_growth(const size_type _Newsize) const {
    const size_type _Oldcapacity = capacity();
    const auto _Max              = max_size();
    //扩容后将超出max_size，返回max_size
    if (_Oldcapacity > _Max #### _Oldcapacity / 2) {
        return _Max; 
    }
	//采取1.5倍扩容
    const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;
	//扩容后仍然小于新加入元素后的大小，以新加入元素后的大小为准
    if (_Geometric < _Newsize) {
        return _Newsize; 
    }
    return _Geometric;
}
```

*追问：查找map里面的元素可以用`count()`也可以用`[]`，一般我们不用方括号是为什么？*

使用`[]`如果本身不存在该Key会插入一次，但是我一般用find

*追问：如果我要用迭代器去遍历map，并且删除其中一些元素，需要注意什么？*

会减小map的大小应该使用倒序遍历的方式删除，可能出现失效的迭代器，需要，如果使用erase删除会返回下一个元素，需要用迭代器接收。

```cpp
在C#中的话一般采用倒序删除，因为倒序删除只对后面的索引产生影响，对前面的索引没有影响
还有可以使用递归，但是通用性不强
```

```cpp
for(auto iter = m.begin(); iter != m.end();)
{
	if (iter->first == 4)
	{
		iter = m.erase(iter);
	}
	else
		++iter;
}
```

#### 你能介绍一下二分查找的实现过程吗？
二分查找是在有序数组中进行的，首先有两个指针指向left和right，还有一个指针指向通过left和right的中间值mid。将mid与target对比，如果mid比target大了说明target在mid左边，于是将right减小到mid-1，如果mid比target小了说明target在mid右边，于是将left增加到mid+1，否则就是相等，放回该mid，如果`left==right`还没有找到，那就是没有

#### 如何判断一个点在三角形内
叉乘法
重心坐标法

#### 网络编程有了解吗？粘包、大小端什么的有了解吗？
因为TCP是面向字节流的网络协议，在底层有滑动窗口，如果一个消息的包体较小，那么TCP将会将多个包在一起发送，这是粘包现象
如果消息过大，TCP会分割包体大小，分成几次发送，这就是分包
我们通过在消息头中封装消息长度来解决

#### 看你C#用得比较多，泛型、反射之类的用过吗？
用的很多，泛型在很多时候都会用，比如我的对象池里，普通Object的对象就是用泛型类来创建。
反射用的也很多，但是多在编辑器开发中使用，因为反射的性能消耗较高
反射的原理是是在运行每一个类都有一个Type对象,运行时的对象本质上是一个一个的内存块,Type中有methodInfo(名称 类型 代码段的偏移地址 大小) fieldInfo(名称 类型 偏移地址 大小), 这样我么通过Type就可以获取到这个类的所有信息

---

#### C#如何被打包在目标平台  
在C#中，代码通常被编译为中间语言（Intermediate Language，IL），而不是直接编译为目标平台的本机代码。这意味着C#代码在目标平台上运行时，需要通过一个称为“Just-In-Time”（JIT）编译器将IL代码转换为目标平台的本机代码。

#### 线程和进程的数据交流 。**灵2**
管道通信 共享存储 消息传递

#### Unity的对GameObject的理解  
GameObject是一个游戏中的对象,他在运行时可以每帧都执行一定的函数,相当于一个独立体,我们可以在GameObject上挂载很多MonoBeahavoir脚本来实现不同的功能,GameObject可以有父对象和子对象,同一个GameObject上的组件可以方便的互相访问

#### Camera的属性，必须具备的属性。**灵2**
近平面、远平面、位置、上方向、视口大小？

#### 协程和线程进程的区别  **灵2**
协程是用户级的由用户调用和管理 
协程切换的开销较小  
协程终究是运行在线程中的，一个协程卡死这个线程也会卡死
共享一个线程中的所有数据

线程是内核级的由操作系统管理
线程是**任务调度和系统执行**最小单位 线程切换的开销较大（需要内核调用 直接消耗：指的是CPU寄存器需要**保存和加载,** 系统调度器的代码需要执行, **TCB实例**需要重新加载, CPU 的pipeline需要刷掉。） 
一个线程可以包含多个协程

我使用C\#写过简单的协程，使用迭代器实现，关键类是协程管理类、等待类，使用迭代器中的MoveNext和Current巧妙地管理每个协程是否运行

#### 大顶堆和小顶堆，插入具体的过程  （我：与单调栈什么关系？）
以大根堆为例,给到一个数组,我们将这个数组看作大根堆,先找到最后一个非叶子节点进行上律,分别判断左右是否大于父节点,大于就交换,交换之后判断其交换之后的子树是否满足大根堆,不满足则重新调整。

```cpp
/**
 * 构建大顶堆
 * 大顶堆的性质：每个结点的值都大于或等于其左右子结点的值。
 */
function buildBigHeap(int[] arr,int len) {
    for (int i = floor(len/2); i >= 0; i--) {
        //根节点小于左子树
        if (2 * i + 1 < len && arr[i] < arr[2 * i + 1]) {
            //交换根节点和左子树的值
            swap(arr, i, 2 * i + 1);
            // temp = arr[i];
            // arr[i] = arr[2 * i + 1];
            // arr[2 * i + 1] = temp;
            //检查左子树是否满足大顶堆的性质，如果不满足，则重新调整
            if ((2 * (2 * i + 1) + 1 < len && arr[2 * i + 1] < arr[2 * (2 * i + 1) + 1])
            || (2 * (2 * i + 1) + 2 < len && arr[2 * i + 1] < arr[2 * (2 * i + 1) + 2])) {
                buildBigHeap(arr, len);
            }
        }
        //根节点小于右子树
        if (2 * i + 2 < len && arr[i] < arr[2 * i + 2]) {
            //交换根节点和右子树的值
            swap(arr, i, 2 * i + 2);
            //检查右子树是否满足大顶堆的性质，如果不满足，则重新调整
            if ((2 * (2 * i + 2) + 1 < len && arr[2 * i + 2] < arr[2 * (2 * i + 2) + 1])
            || (2 * (2 * i + 2) + 2 < len && arr[2 * i + 2] < arr[2 * (2 * i + 2) + 2])) {
                buildBigHeap(arr, len);
            }
        }
    }
}
```

[图解大顶堆的构建、排序过程 #### 鹿呦呦 #### 博客园 (cnblogs.com)](https://www.cnblogs.com/sunshineliulu/p/12995910.html)

#### 斐波那契树  
[斐波那契堆(Fibonacci heap)原理详解(附java代码实现) - 转瞬之夏 - 博客园 (cnblogs.com)](https://www.cnblogs.com/junyuhuang/p/4463758.html)

---
#### pbr  
#### ECS是什么，怎么实现的，什么优点  
####  阴影算法、抗锯齿  
[深入剖析MSAA多重采样抗锯齿（multisample anti-aliasing）-CSDN博客](https://blog.csdn.net/aoxuestudy/article/details/117952164)
[常见抗锯齿原理：FXAA、SMAA、TAA - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/690623995)
[FXAA算法演义 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/373379681)
[深入剖析MSAA - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/32823370)

#### 渲染透明物体
深度写入 渲染队列 对于半透明物体可以使用混合

#### 渲染大量物品怎么优化
[Unity下大量物体同屏渲染的性能优化思路 #### 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/114646617)
遮挡剔除 lod  GPUInstance  
GPU蒙皮动画,对顶点进行采样保存在Texture中 缺点是会增加内存消耗  在顶点着色器中解析顶点数据 并且做相应的变换,还可以对骨骼采样对骨骼采样的内存消耗更加少
动画剔除 

#### 哈希的实现方式
通过哈希函数将值映射到地址上 用大于长度的最小质数
哈希冲突 连地址法 开放定址法(线性探测法)

#### 帧同步，帧同步怎么实现的，要注意什么     **灵2**
帧锁定同步，服务器接收到游戏开始消息，下发第0帧，客户端接收到第0帧后间隔33ms（30FPS）收集玩家数据并且转发给服务器，服务器接收到当前帧（第0帧）的所有玩家的操作后，将操作转发到所有客户端，并且将当前逻辑帧+1，客户端接收到（第0帧）数据后对所有游戏对象进行一个逻辑更新，再等待33ms收集玩家数据并且转发给服务器 

帧同步最重要的点就是相同的输入要的到相同的输出，因为逻辑是跑在玩家的电脑上而不是同一的

1.对此我们使用**定点数**代替浮点数来避免浮点数造成不同电脑上的误差，

2.还有就是是不要使用**多线程**，使用多线程不能保证，相同输入下的相同输出

3.对于**随机的数**，我们选择在计算随机数的时候使用随机种子保证随机的结果一致。

4.如果使用物理引擎,那么物理引擎是**确定性**的

5.不要使用**不确定排序的容器**


#### 状态同步与帧同步的技术差异、优缺点**√**
1.逻辑运行地点-》安全性-》性能开销-》开发难度
2.转发类型-》带宽消耗
3.特性-》短线重连-》客户端性能 

---

自己拷问自己项目

---
#### MVC设计模式 
将程序分为三个部分,模型层、视图层、控制层,在模型层中只有数据，在视图层中只负责UI的绘制，我们用Contorller层充当中介来监听数据变化，和更新UI。
通常会配合观察者模式、和工厂模式使用。

#### protobuf VS json（protobuf：variant，zigzag）
https://www.jianshu.com/p/73c9ed3a4877
varints编码真的牛逼，可以省略高位的零，进而压缩二进制编码，
比如这里编码数字 666，Varints 只使用了 2 个字节。而正常情况下 int32 将使用 4 个字节存储数字 666。

```protobuf
int32 val = 666; // 设置一个 int32 的字段的值 val = 666; 这时编码的结果如下
原码：000 ... 101 0011010 (一共32位) // 666 的源码
补码：000 ... 101 0011010 （一共32位） // 666 的补码
Varints 编码：1#0011010  0#000 0101 （9a 05）  // 666 的 Varints 编码
```

#### 有深入了解过2D/3D物理引擎的框架吗？
我了解和实现过OBB算法，这个算法的基本思想是，
遍历每一个边，得到每一个边的法线，将图形(C1)的每一个点投影到这个法线上,然后得到两个在轴上的点一个表示在轴线投影上的最小值(pmin)，一个表示在轴线投影上的最大值(pmax)，让后让另外一个图形(C2)做相同操作，之后判断相交性，如果(C2.pmin-C1.pmax>0 || C1.pmin-C2.pamx>0) 说明有缝隙不相交，否则继续遍历(对两个图形的所有边)，进行相交性检测。
对于三位图形也是同理的。

#### 怎么判断子弹与人物的碰撞
用连续的射线检测,在子弹上一秒和下一秒的位置连上一根射线如果射线打中了物体那么就发生了碰撞。

#### C#与C++的异同、优缺点
C\#无需用户进行内存管理,确定性能没有那么好,GC会有性能问题,没有指针,类型安全
C++需要用户内存管理,有内存泄漏的可能,没有GC不用避免GC的性能问题,有指针

#### 四元数 
可以解决欧拉角的一些问题,比如旋转必须是有序的,相同的值不能得到相同的结果,万象锁
但是欧拉角是四维空间的量,不好再三维中理解
四元数的左乘四元数可以理解为相加(视觉上)
四元数\*三维向量,可以看作做这个四元数的旋转


#### 了解过C#的中间语言吗？（只知道有这个东西。。。）
了解过,了解了IL的一些基本语法,能够看懂简单的C\#代码,转换成的IL代码的含义,了解部分IL指令的执行过程

#### C#的字符串是什么类型C#两个字符串相同，指向同一个地方吗？
在C#中，字符串是引用类型。
在C#中，字符串是不可变的，这意味着如果两个字符串包含相同的字符序列，则它们实际上指向内存中的同一位置。这是因为C#中的字符串在内存中被视为常量，会被存储在字符串池中，因此相同的字符串只会在内存中存储一次，多个变量引用相同的内存地址

#### 工厂模式
工厂模式优点：封装、扩展、解耦、隐藏复杂逻辑、提高可测试性。
工厂模式缺点：增加类数量、不适用于单个对象、抽象工厂模式扩展性差
例如在脚本状态机中，创建状态、删除状态、添加过渡、删除过渡中就使用了工厂模式
因为状态与状态之间是有过渡连接起来的，我们删除状态就要对应的删除过渡，使用工厂模式进行封装，直接在工厂方法中删除了对应的过渡，使得外部处理逻辑的时候，无需在意这些额外的逻辑

#### unity协程?unity协程和C#多线程使用上的区别，C#异步?
unity中的协程是使用IEnumerator来实现的,其中有**两个非常重要的成员**,一个是**MoveNext**,一个是**Current**,MoveNext使得IEnumarator执行到下一个**yiled return**的位置,之后通过**Current**可以得到**yiled return**的对象,Unity就是同一管理协程,判断**yiled return**的对象(比如是一个计时器 new WaitForSecond)那么就在一定事件内都不让这个协程**MoveNext**。

线程是内核级的,是CPU运行的最小单位,而协程是自定义的用户级的
协程本质还是运行到一个线程中的,如果一个协程卡死,其他协程都会卡死
协程的切换开销比线程要小

#### 快速排序的原理，时间复杂度**√**     **灵**
选择基本元素，使得基本元素左边的元素小于他，右边的元素大于他
对基本元素左右两边递归进行次操作
时间复杂度取决于基本元素的选取，最好情况为O(n log n)最坏情况O(n^2)


#### 哈希表，和它的缺点**√**
便于键值对的查找
缺点：哈希冲突 无序性

#### C#怎么用指针**√**
在项目中启用unsafe选项，
引用类型不可以转化为指针，以为在C\#中是自动垃圾回收，要经过标记压缩算法，内存地址是不固定的，所以要使用指针必须让其指向固定的内存地址，要使用fixed关键字

#### 银行家算法**√**
避免死锁产生的算法
主要是： 找到一个安全序列（使得系统按照这个序列分配资源，每个进程都能够顺利运行）
该算法的概述： 找到一个剩余资源能够满足的进程，分配给他相应资源，将进程加入安全序列，计算这个进程执行往后，归还资源，所剩余资源，继续找到一个剩余资源能够满足的进程，循环下去，如果找到了一个序列包含了所有的进程那么就是找到了一个安全序列，按照这个序列分配资源可以避免死锁

#### 资源动态加载方式有哪些**√**
Resouce、AssetsBundle、Addressable

#### 对于AssetBundle的依赖问题
先加载主包**AssetBundleManifest**，然后先加载该AB包的依赖包
维护一个已加载列表，加载过的不再加载

#### A星的缺点**√**
空间需求,需要保存开发列表与关闭列表
启发函数的选取
对于无法到达问题的多余消耗

#### 委托**√**
事件委托用于实现**观察者模式**，允许一个对象订阅和通知其他对象发生的事件。事件委托通常由两个步骤组成：定义委托类型和定义事件。
定义委托类型：委托是一个类，用于**封装方法的引用**。它定义了方法签名，指定了委托可以引用的方法的**参数类型和返回类型**。例如：
可以把事件看作一个函数的容器,触发一个事件会调用所有其中的函数


#### 进程线程、通信**√**
共享存储,管道通信,消息传递

#### 四次挥手
客户端和服务器皆处于连接建立的状态
第一次挥手: 客户端发起一次断开请求FIN,此时客户端处于等待断开1阶段
第二次挥手: 服务器接收到断开请求后,立即相应一次ACK
第三次挥手: 此时客户端接收到FIN的ACK处于等待断开2阶段,服务器将所有要发送的消息发送出去之后,再次发送断开请求FIN,服务器处于最后确认状态
第四次挥手: 客户端接收到FIN请求,发送FIN应答ACK,**等待一段时间后**进入断开状态
服务器接收到ACK后处于断开状态

#### 为什么要等待一段时间?(防止最后一次ACK丢失)
如果最后一次ACK丢失,但是客户端直接关闭,那么服务器将一直重传FIN且得不到ACK相应

#### 三次握手:
客户端处于关闭状态 服务器处于监听状态
第一次握手: 客户端发起一次SYN同步请求
第二次握手: 服务器接收到SYN请求,发起一次ACK应答与SYN同步请求
第三次握手: 客户端接收到服务器的SYN应答,成功建立连接,客户端发送一次ACK应答
服务器接收到最后一次ACK成功建立连接

#### 为什么不是两次握手?(防止接收到失效的SYN请求)
如果只有两次握手,那么意味着客户端发送第一次SYN服务器这边就直接建立连接,如果此时接受的SYN是过时消息,且客户端已经关闭,那么这个服务器资源将一直处于连接建立状态,而占用资源

#### 帧同步 乐观帧 表现不一致 
表现不一致: 定点数 和 随机种子 逻辑部分不使用Coroutine，不依赖类似Dictionary等不确定顺序的容器的循环等

还有最基础的，要通过一个统一的逻辑tick入口，来更新整个战斗逻辑，而不是每个逻辑自己去Update。保证每次tick都从上到下，每次执行的顺序一致。

#### 预测回滚
[关于帧同步的想法（预测和回退） #### 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/657629533)
关于帧同步如何做，包括预测、回退，看了知乎一个简要明了的回答：
> 1、客户端逻辑与表现分离（帧同步必备）；  
> 2、表现层进行预表现，即表现层立即响应本地输入，逻辑层则等服务器的包到了之后再响应，当逻辑与表现不一致较明显时，通过插值等方式平滑过渡到逻辑位置。

#### 乐观帧
[关于帧同步的想法（预测和回退） #### 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/657629533)
**“定时不等待”** 的乐观方式再每次Interval时钟发生时固定将操作广播给所有用户，
不会再等到搜集完所有用户输入再进行下一帧

#### 用定点数实现了哪些数学函数？
加减乘除 

3.两个定点数**相乘**，其**积是含有放大倍数的平方**，所以结果要再**除以放大倍数**。注意，一般会用上2^n为放大倍率，因为这样可以通过右移n位来做这个除数。32位定点数乘以32位定点数的结果是64位的，除法/右移后再转换成32位定点数，但注意乘法有**可能溢出**。

#### 求三角函数值该怎么做？（泰勒展开）
2.三角函数可通过查表或泰勒级数求值，结果是定点数。
![](images/posts/Pasted%20image%2020240412163001.png)

#### 定点数怎么做的？
使用long来模拟,long有64位,将小数点位置设为32,将float转为定点数就是将其左移32位,将定点数转化为float就是右移32位

1.把定点数转换为浮点数后，该浮点数就不应参与帧同步中的任何计算。或者说，帧同步的计算中不需要转换为浮点数。

#### 说一下重载和重写**√**
重载: 重载是对于同名函数不同参数
重写: 子类对父类函数的重写
重定义: 等价于C#中的隐藏(隐藏父类的成员)

#### GC**√**
垃圾回收 内存管理
压缩标记算法
年龄算法

#### 内存五大区**√**
堆栈区 代码区 静态变量区 文字区

#### 观察者模式,优缺点**√**   **灵**
比如 玩家胜利了 有其他多个地方需要监听 例如 音乐系统播放音乐 UI系统打开胜利界面 等等 
优点: 解耦性 符合开放封闭原则(对扩展开放，对修改关闭)
缺点: 避免循环依赖 耗时操作导致性能下降

#### 对象池优缺点**√** 
#### 项目里用到了对象池，如何设计的对象池，什么东西要用对象池生成？   **灵2**
优点: 减少GC频率 重复使用对象
缺点: 维护对象池有一定内存消耗 线程安全 对象引用

使用了Dictonary<Key,Pool>来保存对象，Pool中储存了一个List这个list中装了同类型的对象，还有Get和Push方法，在get方法中将GameObject激活并且从Pool中删除，并且放置到相应位置，在push方法中将GameObject失活，并且加入到Pool中。

关于对象池的注意事项,如果某个类要持有对象池中的对象,一定要注意判空,防止空引用

#### 碰撞检测的前置条件**√**
都拥有Collider组件
其中一个有RigidBody
保证在Unity的Physics设置中勾选了两个Layer的碰撞

#### 脚本生命周期**√**
OnAwack
OnStart
OnUpdate
OnFixedUpdate
OnLaterUpdate
OnDisable

#### MVP矩阵的作用**√**
通过MVP矩阵将模型从事件空间转换到屏幕空间。

MVP矩阵具体有,Model矩阵从世界坐标转换到原点,我的软光栅项目中没有写到,因为本项目中加载的模型大都在原点。

View矩阵其实叫做CameraView矩阵根加好,将物体转换到相机坐标下

Projection透视矩阵,将模型变化为人眼的近大远小的矩阵。

#### 渲染管线介绍**√**
Application(读取模型顶点 面 法线 UV 纹理等等) --> 顶点阶段(遍历三个顶点) --> 光栅化 --> 片元阶段 --> 着色 

#### TCP为什么是可靠的**√**
停止等待(等待N帧 ACK 滑动窗口 确认应答)
校验和(checkSum)
序列号(seq)

#### 值类型引用类型**√**
存储区域
赋值方式
传递参数


#### 堆栈**√**     **灵**
分配速度
管理方式
数据结构

#### Lua的协程**√**
协程的四个状态 dead(结束)，suspended(暂停)，running(运行)
创建`coroutine.creat  coroutine.warp`
运行或继续`coroutine.resume`
挂起`coroutine.yiled`

#### 状态同步与帧同步的技术差异、优缺点**√**
安全性 重连 带宽消耗 客户端性能 开发难度

#### 帧同步还得加强描述**√**
服务器
1. 玩家就位后发送**第0帧**的操作，第0帧都是空操作。
2. 等待**第1帧**的所有玩家接收操作到位。
	1. 接收到位后，广播所有玩家当前帧操作，当前帧加一。
客户端：
1. 等到**第0帧**的到来，**第0帧**没到不允许上传操作。
	1. 接收到第0帧后，更新逻辑帧。
2. 接收到**第0帧**后，等待66ms（FPS：15）搜集并且上传**第1帧**的操作，没有接收到不允许上传

#### 装箱和拆箱**√**     **灵** int到string需要拆装箱吗?
(装箱)将**值类型**->**引用类型** 把**栈**中内容迁移到**堆**中去
(拆箱)将**引用类型**->**值类型** 把**堆**中内容迁移到**栈**中去

#### 进程与线程的区别，进程间通信的方式**√**
区别:
进程是操作系统进行**资源分配**的最小单元，线程是操作系统进行**运算调度**的最小单元
在现代多核心CPU线程是**内核级**的, 协程是用户级的
切换的开销不同,线程的出现就是因为进程切换的开销太大
同一个进程中的线程资源共享,而进程不共享资源
同行方式:
共享存储
管道通信
消息传递

#### 死锁，如何避免**√**
产生条件: 互斥 不剥夺 请求和保持 循环等待 
1.预防死锁(对死锁产生条件破坏) 
2.避免死锁(银行家算法))

#### 指针和引用区别**√**
定义 多级指针 没有多级引用  初始化 是否可以指向NULL 指针可变 引用不可变 所需内存空间不同 自增运算符含义 判空

#### new和malloc区别**√**
返回值的安全性
失败时的处理
是否需要指明大小
是否调用构造函数
对应的释放内存delete free
是否可以之后扩充内存

#### 树的遍历方式**√**
前序中序后序遍历 层序遍历

#### 图的遍历**√**
深度优先和广度优先

#### 图优化的遍历方式**√**
dfs可以使用队列或者栈来优化

#### 实时光照对DrawCall的影响**√**
对于一个Mesh多一个实时灯光就多一个DrawCall

## 有的没的

#### UI性能
#### UI框架
#### 帧同步 乐观帧 表现不一致 预测回滚 
#### 物理系统
#### 动画模块
#### List ArrayList  性能谁更加好  性能开销**√**
#### Unity分辨率适配 原来是说三个UnityCanvas的模式 一个是固定物理分辨率 一个是 固定像素大小 还有一个是随屏幕大小变化(其中有高度优先 宽度优先 缩放不裁剪 缩放裁剪)**√**
#### MVC设计模式 
#### 快排
#### UI下优化DrawCall
#### 静态合批和动态合批优缺点**√**
#### TCP频繁一直发消息会有频率太高会怎样**√**
#### A\*寻路消耗性能的点
#### UI的边不清晰模糊有锯齿是什么原因造成的(是指纹理采样吗？抗锯齿？图片压缩格式)
#### 我的这个帧同步怎么减小网络延迟(更换为TCP？)

面经:

#### 状态同步与帧同步的技术差异、优缺点
#### 让你自己写可靠UDP怎么做好一点？（答得很平常，面试官没反应）
#### 数组和链表的区别
#### 新增一个元素，数组和链表的区别
#### 快速排序的原理，时间复杂度
#### 二叉树的遍历，三种遍历顺序
#### bfs和dfs的区别，用到的数据结构
#### dfs压栈
#### 指针和引用区别
#### 多态原理
#### tcp和udp的区别

#### unity脚本的生命周期
#### update，lateupdate和fixedupdate
#### unity协程
#### unity协程和C#多线程使用上的区别，C#异步
#### 渲染管线
#### 工厂模式
#### kcp相关（可靠udp）
#### 除了重传，还有什么办法减少udp丢包？（没答出来）
#### kcp确认机制
#### protobuf VS json（protobuf：variant，zigzag）
#### 定点数的实现
#### 怎么判断子弹与人物的碰撞
#### 对象池

#### 最大子数组和
#### 判断括号字符串是否有效，有三种括号{},[],()，()里面有[],{}也是非法的，[]里面有{}也非法。

#### 怎么了解到帧同步的

#### 有深入了解过2D/3D物理引擎的框架吗？（没有。。。）碰撞怎么检测，直接遍历吗？（四叉树、#### BVH、KD-Tree）问的很细，BVH的划分原则，等等
#### 项目中使用BVH了吗？（没有。。。
#### 为什么光线检测要用BVH？（没答对，面试官告诉我是方便在GPU上并行优化）
#### Kcp的好处？
#### Kcp有什么问题需要优化？（没答好，面试官教我。。。）

#### 你们反外挂怎么做的？（怎么突然变成我问面试官了？）面试官先问我的想法，然后再讲他们项目的做法：服务端跑验证程序，敏感数据随机加密。
#### 你们断线重连怎么做的？（又是我问面试官）我只想到追帧，面试官说还可以用内存快照。
#### 给你看看我们的游戏PV，你觉得做这样的游戏需要什么技术栈？（回到面试官问我）
#### 面试官给我介绍他们项目的寻路解决方案（然后我没听太清楚？）
#### 除了C#还用过什么？（C++）
#### C#与C++的异同、优缺点
#### 了解过C#的中间语言吗？（只知道有这个东西。。。）
#### C#的字符串是什么类型？
#### C#两个字符串相同，指向同一个地方吗？
#### C#装箱、拆箱。
#### 用Cpp做过什么项目吗？（没有，做题目用得多）
#### 讲一下移动语义。**----------**
#### 讲一下RTTI（没听说过，面试官提示我四种类型转换），讲一下dynamic_cast原理（不会，瞎猜了一个跟虚函数表有关）。

#### 牛顿迭代法开方
#### 判断多边形是否是凸包

#### 数组和链表的区别
#### 快速排序的原理，时间复杂度
#### 二叉树的遍历，三种遍历顺序
#### bfs和dfs的区别，用到的数据结构
#### dfs压栈
#### 抗锯齿实现
#### 工厂模式
#### 有深入了解过2D/3D物理引擎的框架吗？（没有。。。）碰撞怎么检测，直接遍历吗？（四叉树、BVH、KD-Tree）问的很细，BVH的划分原则
#### Kcp
#### kcp确认机制
#### 状态同步与帧同步的技术差异、优缺点
#### NPR的算法描边
#### Animator骨骼动画
#### unity协程和C#多线程
#### 动作系统有了解吗？animator的底层机制
#### C#的中间语言
#### protobuf VS json（protobuf：variant，zigzag）
#### 定点数的实现(两次了哦)
#### 怎么判断子弹与人物的碰撞
#### 裁剪发生在具体哪个阶段
#### 对象池
#### 几何着色器?(什么是几何着色器,难道是片元着色器吗?)
#### 射线与三角片相交检测
#### 死锁，如何避免
#### 延迟渲染，图集
#### 物理模拟做过吗
#### 虚拟地址
#### 有GC还会产生内存泄漏吗
#### collider trigger区别
#### PBR
#### 内存碎片如何解决(也只有C++问这个问题了)
#### 如何实现C++多态、C++多态，虚函数，虚函数表(提到两次了)
#### 什么情况下需要使用多继承
#### STL中的多继承
#### 虚继承原理
#### 右值引用和移动语义
#### C++内存管理方式
#### shared ptr的具体实现（问的很细
#### 半透明的绘制(提到两次了)**√**
#### map和unordermap底层，区别，时间复杂度

#### 各种STL容器底层实现
#### vector和list的使用场景
#### stack适配器的底层容器是什么，能不能用vector，为什么
#### 三次握手四次挥手**√**
#### 讲一下free和delete、new 和 malloc的区别
#### 左值右值
#### 强制转化类型
#### 智能指针
#### 静态联编和动态联编
#### 菱形继承
#### 四元数
#### lateupdate里才实现相机跟随
#### 无限循环列表
#### 左值右值 **----------**
