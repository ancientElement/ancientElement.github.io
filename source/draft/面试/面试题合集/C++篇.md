---
title: C++篇
date: 2024-02-24
tags:
  - 面试题合集
  - CPP
---
## C++篇
### C++和C的区别  
1. C++保留了C语言原有的所有优点，增加了**面向对象的机制**

虽然可以使用C实现面向对象，但是也是重复制造C++，虽然我没有在C++中实现过面向对象，但是在lua中实现面向对象，lua中有一个非常重要的概念`mateTable`因为lua中所有东西都是`table`，`table`中可以通过修改`mateTable`，在访问该`table`时所没有的方法和变量时指向他的`mateTable`，由此可以实现`new``extend``virtual`等。

2. 在C++中，**函数原型**必不可少，但是在C中是可选的

`int (*pfunc)();`在C中，这玩意竟然可以代表所有返回值为int的pfunc函数无论他的参数是什么，我好像有一段时间在找这个玩意怎么在C#里实现，在C++中这个与`int (*pfunc)(void)`;没有区别。

### 联合体、结构体、类的区别  
#### 1. 结构体和类

在C++中结构体和类没有很大的区别，结构体中默认成员是`public`而类中是`private`，结构体是值类型，类是引用类型，结构体存在栈中，类存在堆中。

在C#中结构体默认是`private`，不允许定义无参构造函数。

### 说一说多态
#### 1. 重载

同一作用域下，同名函数不同参数，

#### 2. 重写

派生类对基类作用域下同名(参数、返回值)虚函数函数进行覆盖

#### 3. 重定义

派生类对基类作用域下同名(参数、返回值)函数进行隐藏
在C#中用new关键字重定义

### 虚函数

当一个类有一个以上虚函数时，那么这个类便会包含一张虚函数表。而当一个子类继承并重载了基类的虚函数时，它也会有自己的一张虚函数表，虚函数表中存的是函数指针。

![](/images/posts/v2-e2f479ca9b1c56ac33dfae896ce56f49_720w.webp)

函数重载后，会在自己的虚函数表中的指针指向重载过后的函数，而未重载的函数虚函数表中的指针与基类相同。

**纯虚函数**，（抽象函数）在C#中有`abstract`关键字,在C++中在函数后加上 `= 0`表示,例如:`int pfun() = 0`,没有函数体。
在C++中纯虚函数用`overrid`重写，虚函数用`virtual`重写。在C#中都用`overrid`。

纯虚函数的类也称为**抽象类**，是为了让使用者必须override整个类，从而无法被实例化，从编译器层面禁止了无实际意义的class对象的创建。C#一样。

### STL
#### 1. 模板类和模板方法（泛型）

通过模板实现泛型编程，实现运行时多态，

建立一个通用函数，其函数返回值类型和形参类型可以不具体制定，用一个**虚拟的类型**来代表。

建立一个通用类，类中的成员数据类型可以不具体制定，用一个**虚拟的类型**来代表。

比如，资源加载中有许多类型的资源进行加载，我拿到资源需要进行判空，类型转化等操作，可以封装一个函数，传入资源的类型在函数里就进行判空和类型转化，直接可以拿到资源进行使用。

#### 2. 容器
##### - ⭐`std::vector<T>`，对对应C#中`List<T>`

vector容器的迭代器是支持随机访问的迭代器。
vector数据结构和数组非常相似，也称为单端数组。
vector与普通数组区别：数组是**静态空间**，而vector可以动态扩展。
并不是在原空间之后续接新空间，而是找更大的内存空间，然后将原数据拷贝新空间，释放原空间。
应该合理的分配初始空间，防止进行较大的拷贝。

### 简述数组与指针的区别

- `数组`是直接访问数据的。
- `指针`是间接访问数据的。
##### 定义:

- `数组`是类型相同、数目固定的若干个变量的有限集合，它存放的是数据。
- `指针`是变量的地址，存放的是变量的地址。

##### 存储方式：

- `数组`通常存储在静态存储区或栈上。
- `指针`可以随时随地地指向任意类型的内存块。
##### 内存容量：

- 用运算符`sizeof`可以计算出数组的容量(字节数)。
- `sizeof(p)`，`p`为指针得到的是一个指针变量的字节数，而不是p多指的内存容量。

### new和malloc区别

#### 申请内存的位置不同：

- new 操作符从**自由存储区（free store）** 上为对象动态分配内存空间，自由存储区是 C++ 基于 new 操作符的一个抽象概念，凡是通过 new 操作符进行内存申请，该内存即为自由存储区。自由存储区**不仅可以是堆**，还可以是**静态存储区**或**线程局部存储区**，这取决于 operator new 在哪里为对象分配内存。需要注意的是，使用 new 申请的内存空间，需要使用对应的 delete 释放内存，否则会出现内存泄漏问题。
- malloc 函数从**堆上动态分配内存**。需要注意的是，使用 malloc 申请的内存空间，需要使用对应的 free 释放内存，否则会出现内存泄漏问题。

#### 返回类型的安全性

- new 操作符内存分配成功时，返回的是**对象类型的指针**，类型严格与对象匹配，无须进行类型转换，故 new 是符合类型安全性的操作符。
- malloc 内存分配成功则是返回 **void 指针**，需要通过**强制类型转换**将 void 指针转换成我们需要的类型，这可能会带来类型安全性的问题。

#### 内存分配失败时的返回值

- new 内存分配失败时，会抛出 **std::bad_alloc 异常**，这个异常可以通过异常处理机制捕获处理。
- malloc 分配失败时返回 **NULL**，需要手动进行错误处理。

#### 分配内存大小

- 使用 new 操作符申请内存分配时**无须指定内存块的大小**，编译器会根据类型信息自行计算。需要注意的是，对于数组类型的内存申请，需要使用 `new[]` 操作符。

- malloc 则需要明确指出所需**内存的尺寸**。

#### 是否调用构造函数/析构函数

- 使用 new 操作符来分配对象内存时会经历三个步骤：

1. 调用 operator new 函数（对于数组是 `operator new[]`）分配一块足够大的，原始的，未命名的内存空间以便存储特定类型的对象。
2. 编译器运行相应的**构造函数**以构造对象，并为其传入初值。
3. 对象构造完成后，返回一个指向该对象的指针。

- 使用 delete 操作符来释放对象内存时会经历两个步骤：

4. 调用对象的**析构函数**。
5. 编译器调用operator delete(或operator delete[])函数释放内存空间。

- malloc不会调用构造函数，free也不会调用析构函数。

#### 对于数组的处理

- C++ 提供了 `new[]` 与 `delete[]` 来专门处理数组类型的分配。new 对数组的支持体现在它会分别调用构造函数函数**初始化每一个数组元素**，释放对象时为**每个对象调用析构函数**。
- 注意 `delete[]` 要与 `new[]` 配套使用，不然会找出数组对象部分释放的现象，造成内存泄漏。
- malloc 并不知道你在这块内存上要放的数组还是啥别的东西，反正它就给你一块原始的内存，在给你个内存的地址就完事。所以如果要动态分配一个数组的内存，还需要我们手动自定数组的大小

#### 是否可以被重载

opeartor new /operator delete 可以被重载。注意，new 表达式和 operator new 是不同的，前者调用后者，严格来说，我们区分的是 new 表达式和 malloc 表达式，所以应该都不支持重载。

#### 是否支持内存扩充

- new 不支持内存扩充
- malloc 在分配内存后，如果内存不足，可以**使用 realloc 进行内存重新分配**，实现扩充。
