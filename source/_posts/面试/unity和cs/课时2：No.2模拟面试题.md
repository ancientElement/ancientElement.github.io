---
tags: ["Unity和CSharp","面试题"]
categories:
  - 面试
  - unity和cs
series: ["Unity和CSharp"]
date: 2023-09-03
title: 课时2：No.2模拟面试题 
---
## **C#**

### **\*1. 请说说你认为C#中 == 和 Equals 的区别是什么？**

我的回答：

​	==与Equals都可以重载,\==是运算符重载,Equals可以直接重载


答案：

1. == 是运算符，Equals是万物之父Object中的虚方法，子类可重写
2. Equals 一般在子类中重写后用于比较两个对象中内容是否相同
    ==在没有运算符重载的前提下时
    引用类型用于比较地址；值类型用于比较值是否相同
3. 运算效率不同，一般Equals没有==效率高，因为一般Equals比较的内容比==多
### **2.** **浅拷贝和深拷贝的区别？可以举例说明**

我的回答：

​	深拷贝是将原数据拷贝到另一个全新的空间,浅拷贝只拷贝地址,改变拷贝后的数据原数据会改变,深拷贝改变拷贝后的数据原数据不会改变。(用C++解释下	)


答案：

浅拷贝：
只复制对象的引用地址
两个对象指向同一内存地址，修改其中一个另一个也会随之变化

深拷贝：
将对象和值赋值过来，两个对象修改其中任意值都不会影响对方

举例：

比如引用对象A和引用对象B
让A = B，就是浅拷贝，此时A、B的引用地址相同，改A中内容，B也变

如果想要深拷贝，简单处理就是new（包括对象中的成员）

### **3. 下面两种获10000个数的方式，哪种效率更高？为什么?**

![img](/images/posts/121347b75e1d633221.png)

我的回答：

​	第二种效率跟高，应为list在增加的过程中会扩容


答案：

方式2的效率更高
因为List本质是数组，我们通过Add往List中添加元素时，会不断的触发扩容
扩容会带来内存和性能上的消耗
内存方面：每次扩容会产生垃圾，还会造成GC的触发
性能方面：每次扩容会进行“搬家”（老数组中内容存入新数组中）


### **4. 请说出下方代码中**

  **1.A处和B处谁先打印？**

  **2.A、B出打印的i值分别是多少？**

![img](/images/posts/121406ed5109338227.png)

我的回答：
​	
1. 没用过finally


答案：
1. B处先打印，A处后打印
2. A处 i = 10，B处 i = 11

考点：finally的执行顺序




### **5. 请问A、B两处 i 的值为多少？**


![img](/images/posts/12142513c4c3739672.png)

![img](/images/posts/121425170ae9635147.png)

我的回答：

​	1.没用过finally


答案：
A、B两处都为11
考点：
1.finally的执行顺序
2.值和引用赋值表现的区别
## **Unity**

### **1.** **Unity中当一个细小高速物体撞击另一个较大物体时，会出现什么情况？如何避免？**

​	细小物体可能会由于速度过大在一帧的距离里直接穿过较大物体，使用连续检测或者使用射线检测辅助。


答案：
1. 我们可以尽量用射线检测来替代细小物体的物理系统碰撞
因为传统的FPS游戏都是通过射线检测加模拟计算来判断伤害的
2. 修改Rigidbody刚体中的Interpolate（插值）和CollisionDetection（碰撞检测）两个参数，来提高碰撞检测的准确性	

### **2. 请简述一下Prefab（预制体）的本质是什么？**

我的回答：

​	本质是序列化的GameObject。


答案：

Prefab的本质就是一个配置文件
其中记录了一个GameObject对象上挂载的脚本信息
并且记录了脚本信息中的可配置的属性信息




### 3.Unity是否支持写成多线程程序？如果支持的话需要注意什么？

​	可以支持多线程，但要注意： 

1. 注意在webgl下不支持
2. 不允许操作UnityEngine命名空间下的所有对象


答案：
支持
注意：
1.只能从主线程访问Unity相关组件、对象以及
UnityEngine命名空间中的绝大部分内容
2.如果多线程中要和Unity主线程同时修改一些数据
可以通过lock关键词加锁
### **4. 请简述一下对象池，在游戏开发中我们什么时候会用到它？**

​	对象池可以复用对象，减少GC的次数，提高用户体验，减少卡顿。

​	当需要不断重复利用对象资源时要用对象池，例如特效、音频AudioSource


答案：
1. 对象池的主要作用是 避免大量创建对象再释放对象时造成的内存消耗，可以有效降低GC发生的频率。我们把不用的对象放入对象池中而不是让它直接变为垃圾，下次需要用到对象时再从对象池中获取，我们通过占用内存来避免更多的内存消耗和GC的发生

2. 在游戏中频繁创建对象、实例化对象的地方，都可以用到对象池。比如前端开发中，游戏中的子弹、伤害字体、特效等等、比如后端开发中线程池等等

### **5. 什么是DrawCall？DrawCall为什么会影响游戏运行效率？如何减少DrawCall？**

​	渲染


答案：
1.什么是DrawCall？
每次CPU准备渲染相关数据并通知GPU的过程称为一次DrawCall

2.DrawCall为什么会影响游戏运行效率？
如果DrawCall次数较高，意味着CPU会花费更多的时间准备渲染数据，这会进行更多的计算，进而影响游戏的运行效率

3.如何减少DrawCall？
2D和UI层面：打图集，并且注意面板中不同图集图片的层级不要穿插
3D模型层面：利用动态批处理和静态批处理，尽量不使用实时光照和实时阴影
等等


